
import logging
import json
import os
import re
import yaml

from git import Repo

from debian import deb822
from debian.changelog import Changelog
from lib.config import CONFIG


class GitRepo(object):
    log = logging.getLogger(__name__)

    def __init__(self, repo=None):
        self._ = repo

    @classmethod
    def import_project(cls, project, store_prefix, git_prefix,
                       branch='master', fetch=True):
        cls.log.info("Importing project '{}' ...".format(project))
        target_path = os.path.join(store_prefix, project)
        os.makedirs(target_path, exist_ok=True)
        if not os.path.exists(os.path.join(target_path, '.git')):
            cls.log.info("Creating new repo '{}' at '{}' ..."
                         .format(project, target_path))
            repo = cls(Repo.init(target_path))
            origin = repo.remote('origin', git_prefix + '/' + project)
            fetch = True
        else:
            cls.log.info("Using existing repo at '{}' ..."
                         .format(target_path))
            repo = cls(Repo(target_path))
            origin = repo.remote('origin')

        if fetch:
            origin.fetch()

        repo.checkout(branch)

        return repo

    def remote(self, name, url=None):
        remote = getattr(self._.remotes, name, None)
        if remote is None:
            remote = self._.create_remote(name, url)

        return remote

    def deep_clean(self):
        self.log.info("Performing deep repo clean ...")
        git = self._.git
        git.clean('-f', '-d', '-x')
        first_commit = git.rev_list('--max-parents=0', 'HEAD').split('\n')[0]
        git.reset('--hard', first_commit)
        git.checkout('master')
        git.pull()

    def checkout(self, branch='master'):
        self.log.info("Checkout branch '{}' ...".format(branch))
        if self._.is_dirty():
            self.deep_clean()

        if branch in self._.heads:
            self._.heads[branch].checkout()
        else:
            origin = self._.remotes.origin
            if branch not in origin.refs:
                origin.fetch()
            self._.create_head(branch, origin.refs[branch])\
                .set_tracking_branch(origin.refs[branch]).checkout()
            self._.git.pull()


class ProjectScanner(object):
    log = logging.getLogger(__name__)

    def __init__(self):
        self.products = yaml.load(open(CONFIG.config.get('common',
                                                         'product_list')))

    def jeepyb_projects(self, pattern='.*'):
        repo = GitRepo.import_project(
            CONFIG.config.get('git', 'jeepyb_config'),
            CONFIG.config.get('git', 'store_prefix'),
            CONFIG.config.get('git', 'url_prefix'))
        projects = yaml.load(open(os.path.join(repo._.working_dir,
                                               'projects.yaml')))
        for project in projects:
            if re.match(pattern, project['project']):
                yield project['project']

    def matched_products(self, project):
        for data in self.products:
            product_data = {}
            for key, value in data.items():
                if key in ['projects', ]:
                    continue
                product_data[key] = value
            for project_data in data.get('projects', []):
                if re.match(project_data['pattern'], project):
                    data = {}
                    data.update(product_data)
                    data.update(project_data)
                    yield data

    def scan_projects(self):
        for project in self.jeepyb_projects():
            for product_data in self.matched_products(project):
                with open('packages.json', 'a') as ofile:
                    try:
                        if product_data['type'] == 'deb':
                            project_data = self.scan_deb_project(project,
                                                                 product_data)
                            # elif product_data['type'] == 'rpm':
                        #     project_data = self.scan_rpm_project(project, product_data)
                        ofile.write('{}\n'.format(json.dumps(project_data)))
                    except Exception as e:
                        self.log.error(e)


    def scan_deb_project(self, project, product_data):
        if product_data['type'] != 'deb':
            return project

        project_data = {
            'product': {
                'name': product_data['name'],
                'version': product_data['version'],
            },
            'distribution': {
                'name': '',
                'version': '',
                'arch': '',
                'alias': product_data['distribution'],
            },
            'spec_project': '',
            'source_project': '',
            'branch': ''
        }

        repo = GitRepo.import_project(project,
                                      CONFIG.config.get('git', 'store_prefix'),
                                      CONFIG.config.get('git', 'url_prefix'),
                                      branch=product_data['branch'])

        spec_path = product_data['spec-dirs'][0]
        changelog_file = os.path.join(repo._.working_dir,
                                      spec_path, 'changelog')
        control_file = os.path.join(repo._.working_dir,
                                    spec_path, 'control')
        series_file = os.path.join(repo._.working_dir,
                                   spec_path, 'patches/series')

        source_packages = []
        binary_packages = []

        if os.path.exists(control_file):
            for para in deb822.Sources.iter_paragraphs(open(control_file),
                                                       use_apt_pkg=False):
                if 'Source' in para:
                    source_packages.append(para)
            for para in deb822.Packages.iter_paragraphs(open(control_file),
                                                        use_apt_pkg=False):
                if 'Package' in para:
                    binary_packages.append(para)
        else:
            raise Exception("Control file '{}' not found".format(control_file))

        if os.path.exists(changelog_file):
            changelog = Changelog(open(changelog_file), strict=False)
        else:
            raise Exception(
                "Changelog file '{}' not found".format(changelog_file))

        project_data['spec_project'] = project
        project_data['source_project'] = project.replace('-build', '')

        project_data['source_package'] = source_packages[0]['Source']
        project_data['section_name'] = source_packages[0]['Section']

        for key in ['Build-Depends', 'Build-Depends-Indep']:
            for dep in map(lambda s: s.strip(),
                           source_packages[0].get(key, '').split(',')):
                dep = '|'.join(
                    map(lambda s: s.split()[0] if s else '', dep.split('|')))
                if dep:
                    project_data.setdefault('build_depends', []).append(dep)

        if os.path.exists(series_file):
            for patch_name in open(series_file):
                patch_name = patch_name.rstrip()
                if re.match(r'^\s*#', patch_name):
                    continue
                matches = re.findall(
                    r'(?:^|[\/_-])([Cc][Vv][Ee](?:\d{4,}|[_-])+)[\.-]',
                    patch_name)
                for m in matches:
                    project_data.setdefault('cves', []).append(m)

        project_data.setdefault('version', {})
        project_data['version'] = {
            'epoch': changelog.epoch or 0,
            'version': changelog.debian_version,
            'revision': changelog.debian_revision,
            'full_version': changelog.full_version
        }
        project_data['upstream_version'] = changelog.upstream_version

        for block in changelog:
            project_data['distribution_version'] = block.version.full_version
            if re.match(r'.*\@(ubuntu|canonical)\.com.*', block.author):
                project_data['distribution']['alias'] = block.distributions
                if 'cloud' in block.version.full_version:
                    project_data['package_origin'] = 'Ubuntu Cloud Archive'
                else:
                    project_data['package_origin'] = 'Ubuntu'
                break
            if re.match(r'.*\@debian\.org.*', block.author):
                project_data['distribution']['alias'] = block.distributions
                project_data['package_origin'] = 'Debian'
                break
        else:
            project_data['package_origin'] = 'Mirantis'

        for package in binary_packages:
            pkg = {}
            pkg['name'] = package['Package']
            for dep in map(lambda s: s.strip(),
                           package.get('Depends', '').split(',')):
                dep = '|'.join(
                    map(lambda s: s.split()[0] if s else '', dep.split('|')))
                if dep:
                    pkg.setdefault('depends', []).append(dep)
            project_data.setdefault('binary_packages', []).append(pkg)

        return project_data


class DebianVersion(object):
    def __init__(self, version):
        self.epoch = 0
        self.version = ''
        self.revision = ''
        self.suffix = ''
        self.mos_distribution = ''
        self.mos_suffix = ''
        self.full_version = version

        l = self.full_version.split(':', maxsplit=1)
        if len(l) == 2:
            self.epoch = l.pop(0)

        re_version = r'^(.*)(~u\d{2}\.?\d{2})(.*)$'
        match = re.match(re_version, l[0])
        if match:
            self.version = match.group(1)
            self.mos_distribution = match.group(2)
            self.mos_suffix = match.group(3)
        else:
            self.version = l[0]
        l = self.version.split('-', maxsplit=1)
        if len(l) == 2:
            self.version = l.pop(0)
        self.revision = l[0]

        dfsg_version = r'^(.*)([+-]dfsg.*)$'
        match = re.match(dfsg_version, self.version)
        if match:
            self.version = match.group(1)
            self.suffix = match.group(2)
