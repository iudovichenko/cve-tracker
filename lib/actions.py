
import apt
import csv
import datetime
import json
import logging
import os
import re
import tempfile
import yaml

from lib.cpe import CpeWFN

from jinja2 import Environment, FileSystemLoader

from lib.db.api import DBAPI

from lib.misc import DebianVersion

from lib.adapter import AdvisoryAdapter
from lib.adapter import CPEAdapter
from lib.adapter import CVEAdapter
from lib.adapter import SourceProjectAdapter
from lib.adapter import DistributionAdapter
from lib.adapter import DistributionPackageAdapter
from lib.adapter import SourcePackageAdapter
from lib.adapter import ProductAdapter
from lib.adapter import ProductPackageAdapter

from lib.db.models import Advisory
from lib.db.models import CPE
from lib.db.models import CVE
from lib.db.models import SourceProject
from lib.db.models import SourcePackage
from lib.db.models import ProductPackage
from lib.db.models import ProductPackageIssue
from lib.db.models import Distribution
from lib.db.models import DistributionPackage
from lib.db.models import Product

from lib.nvd_feed import ConfigurationNode

from sqlalchemy.orm.exc import NoResultFound


def map_parsed_args(parsed_args, args_map):
    d = {}
    for arg, key in args_map.items():
        value = getattr(parsed_args, arg, None)
        if value:
            d[key] = value
    return d


class Action(object):
    log = logging.getLogger(__name__)

    def __init__(self, parsed_args=None, args_map=None):
        self.db_api = DBAPI()

        if args_map is None:
            args_map = {}

        if parsed_args is None:
            self.mapped_args = {}
        else:
            self.mapped_args = map_parsed_args(parsed_args, args_map)

    def take_action(self):
        raise Exception("Not implemented")


class ImportAdvisoryAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        self.log.info("Importing advisory data from '{}'".format(filename))

        count = 0
        with open(filename) as f:
            adv_list = json.load(f)

            for adv_name, adv_data in adv_list.get('resolved', {}).items():
                count += 1

                adv = AdvisoryAdapter.init(name=adv_name)
                adv.update(adv_data)
                adv.commit()

        self.log.info('Import done. Imported {} advisory object(s).'
                      .format(count))


class ImportCPEAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        self.log.info("Importing CPE data from '{}'".format(filename))

        count = 0
        with open(filename) as f:
            for line in f:
                count += 1
                wfn = CpeWFN(line.strip().replace('"', ''))
                try:
                    cpe = CPEAdapter.init(
                        part=str(wfn.get('part')),
                        vendor=str(wfn.get('vendor')),
                        product=str(wfn.get('product')),
                    )
                    cpe.commit()
                except Exception as e:
                    self.log.exception(e)

        self.log.info('Import done. Imported {} package object(s).'
                      .format(count))


class ImportFeedAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        self.log.info("Importing feed from '{}'".format(filename))

        with open(filename) as f:
            count = 0
            feed = json.load(f)
            for item in feed:
                count += 1
                node = ConfigurationNode()
                node.parse(item['configurations'])
                node.evaluate()

        self.log.info('Import done. Imported {} feed item(s).'
                      .format(count))


class ImportPackageAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        self.log.info("Importing packages data from '{}'".format(filename))

        count = 0
        with open(filename) as f:
            for line in f:
                count += 1
                data = json.loads(line)
                ProductPackageAdapter.update(data)

        self.log.info('Import done. Imported {} package object(s).'
                      .format(count))


class ExportCveAction(Action):
    @staticmethod
    def iter(objs):
        for obj in objs:
            cve = CVEAdapter(obj)
            yield cve.export()

    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        objs = self.db_api.session.query(CVE).all()
        if filename:
            ext = filename.split('.', maxsplit=1)[-1].lower()
            with open(filename, 'a') as f:
                if ext in ['yml', 'yaml', ]:
                    for data in self.iter(objs):
                        f.write(yaml.dump(data))
                else:
                    for data in iter(objs):
                        f.write(json.dumps(data))
                        f.write('\n')
        else:
            for data in iter(objs):
                print(dict(data))


class ExportOvalAction(Action):
    def _iter(self, objs):
        for obj in objs:
            cve = CVEAdapter(obj)
            for issue in cve.product_package_issues:
                package = issue.package
                d = {
                    'cveid': cve.name,
                    'distribution': {
                        'name': package.distribution.name,
                        'version': package.distribution.version,
                    },
                    'product': {
                        'name': package.product.name,
                        'version': package.product.version,
                    },
                    'package': {
                        'name': package.source_package.name,
                        'version': package.version,
                    },
                    'binary_packages': [
                        x.name for x in package.binary_packages],
                    'affected': issue.affected,
                    'resolved': issue.resolved,
                }
                yield d

    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        objs = self.db_api.session.query(CVE).all()
        if filename:
            ext = filename.split('.', maxsplit=1)[-1].lower()
            with open(filename, 'a') as f:
                if ext in ['yml', 'yaml', ]:
                    for data in self._iter(objs):
                        f.write(yaml.dump([data, ]))
                else:
                    for data in self._iter(objs):
                        f.write(json.dumps(data))
                        f.write('\n')
        else:
            for data in iter(objs):
                print(dict(data))


class ExportSourcePackageAction(Action):
    @staticmethod
    def iter(objs):
        for obj in objs:
            pkg = SourcePackageAdapter(obj)
            yield pkg.export()

    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        objs = self.db_api.session.query(SourcePackage).all()
        if filename:
            ext = filename.split('.', maxsplit=1)[-1].lower()
            with open(filename, 'a') as f:
                if ext == 'csv':
                    fieldnames = ['project', 'package', 'origin', 'product',
                                  'distribution', 'binary_package', 'cve']
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    for d in self.iter(objs):
                        for pp in d.get('product_packages', []):
                            datarow = {}
                            datarow['project'] = pp\
                                .get('property', {})\
                                .get('source_project', '')
                            datarow['package'] = '{}-{}'.format(
                                pp.get('distribution_package', {})
                                    .get('source_package', {})
                                    .get('name', ''),
                                pp.get('distribution_package', {})
                                    .get('source_package', {})
                                    .get('version', '')
                            )
                            datarow['product'] ='{}-{}'.format(
                                pp.get('product', {})
                                    .get('name', ''),
                                pp.get('product', {})
                                    .get('version', '')
                            )
                            datarow['distribution'] = '{} {} {}'.format(
                                pp.get('distribution_package', {})
                                    .get('distribution', {})
                                    .get('name', ''),
                                pp.get('distribution_package', {})
                                    .get('distribution', {})
                                    .get('version', ''),
                                pp.get('distribution_package', {})
                                    .get('distribution', {})
                                    .get('arch', ''),
                            )
                            datarow['origin'] = pp\
                                .get('source_package', {})\
                                .get('property', {})\
                                .get('origin', '')
                            datarow['cve'] = ' '.join(
                                [x['cve']['name'] for x in d.get('cves', [])]
                            )
                            for pkg in pp.get('binary_packages', ['', ]):
                                datarow['binary_package'] = pkg
                                writer.writerow(datarow)
                elif ext in ['yml', 'yaml', ]:
                    for data in iter(objs):
                        f.write(yaml.dump([dict(data), ]))
                else:
                    for data in iter(objs):
                        f.write(json.dumps(dict(data)))
                        f.write('\n')
        else:
            for data in iter(objs):
                print(dict(data))


class InitDbAction(Action):
    def take_action(self, *args, **kwargs):
        distributions = [
            {
                'name': None,
                'version': None,
                'arch': None,
                'sources': [],
                'aliases': [],
            },
            {
                'name': 'CentOS',
                'version': '6',
                'arch': None,
                'sources': [],
                'aliases': [
                    'centos6',
                ],
            },
            {
                'name': 'CentOS',
                'version': '7',
                'arch': None,
                'sources': [],
                'aliases': [
                    'centos7',
                ],
            },
            {
                'name': 'Debian',
                'version': '8.0',
                'arch': None,
                'sources': [],
                'aliases': [
                    'jessie',
                ],
            },
            {
                'name': 'RedHat',
                'version': '6',
                'arch': None,
                'sources': [],
                'aliases': [
                    'el6',
                ],
            },
            {
                'name': 'RedHat',
                'version': '7',
                'arch': None,
                'sources': [],
                'aliases': [
                    'el7',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '12.04',
                'arch': None,
                'sources': [],
                'aliases': [
                    'precise',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '14.04',
                'arch': None,
                'sources': [
                    'deb http://archive.ubuntu.com/ubuntu trusty '
                    'main restricted universe multiverse',
                    'deb http://archive.ubuntu.com/ubuntu trusty-updates '
                    'main restricted universe multiverse',
                    'deb http://archive.ubuntu.com/ubuntu trusty-backports '
                    'main restricted universe multiverse',
                    'deb http://security.ubuntu.com/ubuntu trusty-security '
                    'main restricted universe multiverse',
                ],
                'aliases': [
                    'trusty',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '14.10',
                'arch': None,
                'sources': [],
                'aliases': [
                    'utopic',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '15.04',
                'arch': None,
                'sources': [],
                'aliases': [
                    'vivid',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '15.10',
                'arch': None,
                'sources': [],
                'aliases': [
                    'wily',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '16.04',
                'arch': None,
                'sources': [
                    'deb http://archive.ubuntu.com/ubuntu xenial '
                    'main restricted universe multiverse',
                    'deb http://archive.ubuntu.com/ubuntu xenial-updates '
                    'main restricted universe multiverse',
                    'deb http://archive.ubuntu.com/ubuntu xenial-backports '
                    'main restricted universe multiverse',
                    'deb http://security.ubuntu.com/ubuntu xenial-security '
                    'main restricted universe multiverse',
                ],
                'aliases': [
                    'xenial',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '16.10',
                'arch': None,
                'sources': [],
                'aliases': [
                    'yakkety',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '17.04',
                'arch': None,
                'sources': [],
                'aliases': [
                    'zesty',
                ],
            },
        ]

        for data in distributions:
            dist = DistributionAdapter.init(
                name=data.get('name', None),
                version=data.get('version', None),
                arch=data.get('arch', None)
            )
            for src in data.get('sources', []):
                dist.add_property(name='source_list', value=src)
            for alias in data.get('aliases', []):
                dist.add_property(name='alias', value=alias)
            dist.commit()


class ScanDistributionPackageAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        dist = DistributionAdapter(**data)

        rootdir = tempfile.mkdtemp()
        cache = apt.Cache(rootdir=rootdir)
        with open(rootdir + '/etc/apt/sources.list', 'w') as f:
            for name, value in dist.properties(name='source_list'):
                f.write('{}\n'.format(value))

        # Now, lets update the package list
        cache.open(None)
        cache.update()
        # We need to re-open the cache because it needs to read the package list
        cache.open(None)

        for pkg in dist.distribution_packages:
            if not cache.has_key(pkg.name):
                continue
            deb_pkg = cache[pkg.name]
            latest = deb_pkg.versions[0]
            version = DebianVersion(latest.version)
            if pkg.version == version.version:
                print("Matched package {} {}".format(pkg.name,
                                                     version.full_version))
                dist_pkg = dist.add_package(pkg.source_package,
                                            version=version.full_version)
                dist_pkg.commit()


class ReportUnresolvedCveAction(Action):
    def take_action(self, rootdir='.'):
        env = Environment(
            loader=FileSystemLoader('templates')
        )

        template = env.get_template('unresolved-cves.html')
        join = [(ProductPackageIssue, {'resolved': False}), ]
        objs = self.db_api.query(ProductPackage, ProductPackageAdapter,
                                 join=join)
        _rootdir = os.path.join(rootdir, 'html', 'reports')
        os.makedirs(_rootdir, exist_ok=True)
        path = os.path.join(_rootdir, 'unresolved-cves.html')
        with open(path, 'w') as f:
            f.write(template.render(objs=objs))


class RefreshProjectAction(Action):
    def take_action(self):
        objs = self.db_api.session.query(SourceProject).all()
        for obj in objs:
            prj = SourceProjectAdapter(obj)
            prj.refresh()
            prj.commit()


class ExportHtmlAction(Action):
    def take_action(self):
        htmldir = self.mapped_args.get('htmldir', 'html')
        env = Environment(
            loader=FileSystemLoader('templates')
        )
        env.globals['now'] = datetime.datetime.now
        os.makedirs(htmldir, exist_ok=True)

        template = env.get_template('style.css')
        path = os.path.join(htmldir, 'style.css')
        with open(path, 'w') as f:
            f.write(template.render())


        template = env.get_template('distribution.html')
        _rootdir = os.path.join(htmldir, 'distribution')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(Distribution, DistributionAdapter)
        index = []
        for obj in objs:
            index.append((str(obj), obj.id))
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = env.get_template('distribution-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))


        template = env.get_template('product.html')
        _rootdir = os.path.join(htmldir, 'product')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(Product, ProductAdapter)
        index = []
        for obj in objs:
            index.append((str(obj), obj.id))
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = env.get_template('product-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))


        template = env.get_template('advisory.html')
        _rootdir = os.path.join(htmldir, 'advisory')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(Advisory, AdvisoryAdapter)
        index = {}
        for obj in objs:
            add_to_index = False
            for cve in obj.cves:
                if len(list(cve.product_packages)):
                    add_to_index = True
                    break
            if add_to_index:
                try:
                    ts = datetime.datetime.fromtimestamp(
                        float(obj.get_property('released_on', as_scalar=True).value))
                    l1_key = tuple(ts.strftime('%Y %m %b').split(' '))
                except Exception as e:
                    self.log.error("Failed to get released_on timestamp for {}"
                                   .format(obj.name))
                    self.log.error(e)
                    l1_key = ('','','')
                match = re.match(r'^(USN|RH.A)-.*$', obj.name)
                if match:
                    l2_key = match.group(1)
                else:
                    l2_key = ''
                index.setdefault(l1_key, {})\
                    .setdefault(l2_key, [])\
                    .append((obj.name, obj.id))
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = env.get_template('advisory-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))


        template = env.get_template('cve.html')
        _rootdir = os.path.join(htmldir, 'cve')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(CVE, CVEAdapter)
        index = {}
        for obj in objs:
            if len(list(obj.product_packages)):
                parts = obj.name.upper().split('-', maxsplit=2)
                if parts[0] == 'CVE':
                    index.setdefault(parts[0], {})\
                        .setdefault(parts[1], {})\
                        .setdefault(parts[2][:1], [])\
                        .append((obj.name, obj.id))

            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = env.get_template('cve-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))


        template = env.get_template('source-project.html')
        _rootdir = os.path.join(htmldir, 'source-project')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(SourceProject, SourceProjectAdapter)
        index = []
        for obj in objs:
            index.append((str(obj), obj.id))
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = env.get_template('source-project-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))


        template = env.get_template('source-package.html')
        _rootdir = os.path.join(htmldir, 'source-package')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(SourcePackage, SourcePackageAdapter)
        index = []
        for obj in objs:
            index.append(('{}-{}'.format(obj.name, obj.version), obj.id))
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = env.get_template('source-package-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))


        template = env.get_template('distribution-package.html')
        _rootdir = os.path.join(htmldir, 'distribution-package')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(DistributionPackage,
                                 DistributionPackageAdapter)
        index = []
        for obj in objs:
            index.append(('{}-{}'.format(obj.name, obj.version), obj.id))
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = env.get_template('distribution-package-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))


        template = env.get_template('product-package.html')
        _rootdir = os.path.join(htmldir, 'product-package')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(ProductPackage, ProductPackageAdapter)
        index = []
        for obj in objs:
            index.append(('{}-{}'.format(obj.name, obj.version), obj.id))
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = env.get_template('product-package-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))


        template = env.get_template('unresolved-cves.html')
        join = [(ProductPackageIssue, {'resolved': False, 'affected': True}), ]
        objs = self.db_api.query(ProductPackage, ProductPackageAdapter,
                                 join=join)
        _rootdir = os.path.join(htmldir, 'reports')
        os.makedirs(_rootdir, exist_ok=True)
        path = os.path.join(_rootdir, 'unresolved-cves.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', objs=objs))

        template = env.get_template('reports-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..'))


        template = env.get_template('index.html')
        path = os.path.join(htmldir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='.'))


class ApplyCveOverridesAction(Action):
    def take_action(self):
        path = self.mapped_args.get('path', None)
        data = yaml.load(open(path))
        for item in data:
            for key, value in item.items():
                # print({key: value})
                if key == 'source-package' in item:
                    self.update_source_package(value)
                elif key == 'distribution-package' in item:
                    self.update_distribution_package(value)
                elif key == 'product-package' in item:
                    self.update_product_package(value)
                elif key == 'cve' in item:
                    self.update_cve(value)
                else:
                    pass

    def _get_source_packages(self, data):
        packages = []
        if 'package' in data:
            name = data['package'].get('name', None)
            if name is None:
                self.log.error("No 'name' key in '{}'".format(data))
                return packages
            prj = SourceProjectAdapter(name=name)
            for pkg in prj.source_packages:
                version = data['package'].get('version', None)
                if version is None:
                    packages.append(pkg)
                else:
                    if pkg.version == version:
                        packages.append(pkg)
        return packages

    def _update_cve(self, packages, data):
        if 'cve' in data:
            for pkg in packages:
                for issue in pkg.issues():
                    if 'any' in data['cve']:
                        issue.affected = data['cve']['any']['affected']
                        continue
                    cve_name = issue.issue.name
                    if cve_name in data['cve']:
                        issue.affected = data['cve'][cve_name]['affected']
                pkg.commit()

    def update_source_package(self, data):
        """
        :param data:
            package:
              name: ansible
              version: '1.2.3'
            cve:
              any:
                affected: false
        :return:
        """
        source_packages = self._get_source_packages(data)
        self._update_cve(source_packages, data)

    def update_distribution_package(self, data):
        """
        :param data:
            package:
              name: 'qwe'
              version: '123'
            distribution:
              name: 'qwe'
              version: '123'
            cve:
              any:
                 affected: false
        :return:
        """
        source_packages = self._get_source_packages(data)

        packages = []
        if 'distribution' in data:
            for x in source_packages:
                for y in x.distribution_packages:
                    name = data['distribution'].get('name', None)
                    if name and y.distribution.name.lower() != name.lower():
                        continue
                    version = data['distribution'].get('version', None)
                    if version and y.distribution.version != version:
                        continue
                    packages.append(y)

        self._update_cve(packages, data)

    def update_product_package(self, data):
        """
        :param data:
            package:
              name: kernel
            product:
              name: mos
              version: '7.0'
            cve:
            - any:
                affected: false
        :return:
        """
        source_packages = self._get_source_packages(data)

        packages = []
        if 'product' in data:
            for x in source_packages:
                for y in x.product_packages:
                    name = data['product'].get('name', None)
                    if name and y.product.name.lower() != name.lower():
                        continue
                    version = data['product'].get('version', None)
                    if version and y.product.version != version:
                        continue
                    packages.append(y)

        if 'distribution' in data:
            remove_list = []
            for x in packages:
                name = data['distribution'].get('name', None)
                if name and x.distribution.name.lower() != name.lower():
                    remove_list.append(x)
                    continue
                version = data['distribution'].get('version', None)
                if version and x.distribution.version != version:
                    remove_list.append(x)
                    continue
            for x in remove_list:
                packages.remove(x)

        self._update_cve(packages, data)

    def update_cve(self, data):
        """
        :param data:
            CVE-2017-2639:
              source-package:
                name: ansible
                version: 2.2.1.0
              affected: false
        :return:
        """
        for cve_name, cve_filter in data.items():
            affected = cve_filter.get('affected', False)
            try:
                cve = CVEAdapter(name=cve_name)
            except NoResultFound:
                print("Unable to load CVE '{}'".format(cve_name))
                continue

            rval = []
            for x in cve_filter.get('product', []):
                rval.append((x.get('name', '').lower(), x.get('version', '')))
            if rval:
                for x in cve.product_package_issues:
                    lval = (x.package.product.name.lower(),
                            x.package.product.version)
                    if lval in rval:
                        x.affected = affected

            rval = []
            for x in cve_filter.get('product-package', []):
                rval.append((x.get('name', '').lower(), x.get('version', '')))
            if rval:
                for x in cve.product_package_issues:
                    lval = ((x.package.name.lower(), x.package.version))
                    if lval in rval:
                        x.affected = affected

            rval = []
            for x in cve_filter.get('distribution-package', []):
                rval.append((x.get('name', '').lower(), x.get('version', '')))
            if rval:
                for x in cve.distribution_package_issues:
                    lval = (x.package.name.lower(), x.package.version)
                    if lval in rval:
                        x.affected = affected

            rval = []
            for x in cve_filter.get('source-package', []):
                rval.append((x.get('name', '').lower(), x.get('version', '')))
            if rval:
                for x in cve.source_package_issues:
                    lval = (x.package.name.lower(), x.package.version)
                    if lval in rval:
                        x.affected = affected

            rval = []
            for x in cve_filter.get('source-project', []):
                rval.append((x.get('name', '').lower(), ))
            if rval:
                for x in cve.source_package_issues:
                    lval = ((x.package.name.lower(), ))
                    if lval in rval:
                        x.affected = affected

            cve.commit()
