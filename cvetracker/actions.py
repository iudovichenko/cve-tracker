
import csv
import datetime
import json
import logging
import os
import re
import tempfile

import apt
import yaml
from configdir import ConfigDir
from jinja2 import Environment, PackageLoader

from cvetracker.cpe import CpeWFN

from cvetracker.db.adapters import GenericAdapter
from cvetracker.db.adapters import AdvisoryAdapter
from cvetracker.db.adapters import CPEAdapter
from cvetracker.db.adapters import CVEAdapter
from cvetracker.db.adapters import DistributionAdapter
from cvetracker.db.adapters import DistributionPackageAdapter
from cvetracker.db.adapters import DistributionPackageIssueAdapter
from cvetracker.db.adapters import ProductAdapter
from cvetracker.db.adapters import ProductPackageAdapter
from cvetracker.db.adapters import ProductPackageIssueAdapter
from cvetracker.db.adapters import RelatedIssueAdapter
from cvetracker.db.adapters import SourcePackageAdapter
from cvetracker.db.adapters import SourcePackageIssueAdapter
from cvetracker.db.adapters import SourceProjectAdapter

from cvetracker.db.api import DBAPI
from cvetracker.config import CONFIG

from cvetracker.db.models import Advisory
from cvetracker.db.models import CPE
from cvetracker.db.models import CVE
from cvetracker.db.models import Distribution
from cvetracker.db.models import DistributionPackage
from cvetracker.db.models import DistributionPackageIssue
from cvetracker.db.models import Product
from cvetracker.db.models import ProductPackage
from cvetracker.db.models import ProductPackageIssue
from cvetracker.db.models import SourcePackage
from cvetracker.db.models import SourcePackageIssue
from cvetracker.db.models import SourceProject

from cvetracker.email import EmailHelper
from cvetracker.email import EmailMessage

from cvetracker.feedparser import FeedParser
from cvetracker.misc import DebianVersion
from cvetracker.nvd_feed import Node

from cvetracker.jsondiff import JsonFile
from cvetracker.jsondiff import JsonFileIndex
from cvetracker.jsondiff import JsonDiff

from cvetracker.msagen import MSAGenerator


re_bool_true = re.compile(r'^(1|true|yes)$', re.IGNORECASE)
re_bool_false = re.compile(r'^(0|false|no)$', re.IGNORECASE)


def to_bool(string, default=None):
    if re_bool_true.match(string):
        return True
    if re_bool_false.match(string):
        return False
    if default is None:
        raise Exception("Can't cast string '{}' to bool".format(string))
    return default


def map_parsed_args(parsed_args, args_map):
    d = {}
    for arg, key in args_map.items():
        value = getattr(parsed_args, arg, None)
        if value:
            d[key] = value
    return d


class Action(object):
    log = logging.getLogger(__name__)

    def __init__(self, parsed_args=None, args_map=None):
        self.db_api = DBAPI()
        self.attrs = {}

        if args_map is None:
            args_map = {}

        if parsed_args is None:
            self.mapped_args = {}
        else:
            self.mapped_args = map_parsed_args(parsed_args, args_map)

    def take_action(self):
        raise Exception("Not implemented")


class ImportAdvisoryAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        self.log.info("Importing advisory data from '{}'".format(filename))

        index_format = ['{0[__key__]}', ]

        filename_bak = "{}.bak".format(filename)
        if os.path.exists(filename_bak):
            json_diff = JsonDiff(filename_bak, filename)
            for fmt in index_format:
                json_diff.add_index_format(fmt)
            diff = json_diff.diff(('resolved', ))
        else:
            diff = None

        count = 0
        if diff is None:
            with open(filename) as f:
                adv_list = json.load(f)

                for adv_name, adv_data in adv_list.get('resolved', {}).items():
                    count += 1

                    adv = AdvisoryAdapter.new(name=adv_name)
                    adv.update(adv_data)
                    adv.commit()
        else:
            for item in diff:
                data = item.get('rval', dict())
                if data is None:
                    continue

                count += 1
                adv = AdvisoryAdapter.new(name=data['__key__'])
                adv.update(data['__value__'])
                adv.commit()

        GenericAdapter.flush_changes(data.get('changes'))

        self.log.info('Import done. Imported {} advisory object(s).'
                      .format(count))


class ImportCPEAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        self.log.info("Importing CPE data from '{}'".format(filename))

        count = 0
        with open(filename) as f:
            for line in f:
                count += 1
                wfn = CpeWFN(line.strip().replace('"', ''))
                try:
                    cpe = CPEAdapter.new(
                        part=str(wfn.get('part')),
                        vendor=str(wfn.get('vendor')),
                        product=str(wfn.get('product')),
                    )
                    cpe.commit()
                except Exception as e:
                    self.log.exception(e)

        GenericAdapter.flush_changes(data.get('changes'))

        self.log.info('Import done. Imported {} package object(s).'
                      .format(count))


class ImportFeedAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        data.setdefault('feed', list())
        for feed in data.get('feeds', '').split(','):
            if feed:
                data['feed'].append(feed)

        filename = data.get('filename')
        if filename:
            self.import_parsed_file(filename)

        feedparser = FeedParser(feed_filter=data.get('feed_filter'))
        for filename in feedparser.store_feeds(data['feed']):
            self.import_parsed_file(filename)

        GenericAdapter.flush_changes(data.get('changes'))

    def import_parsed_file(self, filename):
        self.log.info("Importing feed from '{}'".format(filename))
        with open(filename) as f:
            count = 0
            feed = json.load(f)
            cve_items = list()
            if isinstance(feed, list):
                cve_items = feed
            if isinstance(feed, dict):
                cve_items = feed.get('CVE_Items', list())
            for item in cve_items:
                nodes = item.get('configurations', dict()).get('nodes', list())
                for node_data in nodes:
                    count += 1

                    impact = item.get('impact', {})
                    cvss_v2_vector = impact.get('baseMetricV2', {}) \
                        .get('cvssV2', {}).get('vectorString')
                    cvss_v3_vector = impact.get('baseMetricV3', {}) \
                        .get('cvssV3', {}).get('vectorString')

                    cve = CVEAdapter.from_nvd(item['cve'])
                    cve.set('cvss_v2', cvss_v2_vector)
                    cve.set('cvss_v3', cvss_v3_vector)
                    cve.commit()

                    node = Node(node_data)
                    result = node.evaluate()
                    if result.data:
                        for package in result.data:
                            package.add_cve(cve)
                            package.commit()

        self.log.info('Import done. Imported {} feed item(s).'
                      .format(count))


class ImportPackageAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        self.log.info("Importing packages data from '{}'".format(filename))

        index_format = [
            '{0[source_package]}-'
            '{0[version][full_version]}-'
            '{0[distribution][name]}-'
            '{0[distribution][version]}-'
            '{0[distribution][arch]}-'
            '{0[distribution][alias]}-'
            '{0[product][name]}-'
            '{0[product][version]}-'
            '{0[product_distribution][name]}-'
            '{0[product_distribution][version]}-'
            '{0[product_distribution][arch]}-'
            '{0[product_distribution][alias]}-'
            '{0[distribution_version]}',

            '{0[source_package]}-'
            '{0[version][full_version]}-'
            '{0[distribution][name]}-'
            '{0[distribution][version]}-'
            '{0[distribution][arch]}-'
            '{0[distribution][alias]}-'
            '{0[product][name]}-'
            '{0[product][version]}-'
            '{0[product_distribution][name]}-'
            '{0[product_distribution][version]}-'
            '{0[product_distribution][arch]}-'
            '{0[product_distribution][alias]}-'
        ]

        filename_bak = '{}.bak'.format(filename)
        if os.path.exists(filename_bak):
            self.log.info("Found '{}', calculating diff ..."
                          .format(filename_bak))

            json_diff = JsonDiff(filename_bak, filename)
            for fmt in index_format:
                json_diff.add_index_format(fmt)
            diff = json_diff.diff()
        else:
            diff = None

        count = 0
        if diff is None:
            with open(filename) as f:
                for line in f:
                    count += 1
                    data = json.loads(line)
                    ProductPackageAdapter.update(data)
        else:
            for item in diff:
                count += 1
                data = item.get('rval', dict())
                ProductPackageAdapter.update(data)

        GenericAdapter.flush_changes(data.get('changes'))

        self.log.info('Import done. Imported {} package object(s).'
                      .format(count))


class ExportCveAction(Action):
    @staticmethod
    def iter(objs):
        for obj in objs:
            cve = CVEAdapter(obj)
            yield cve.export()

    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        objs = self.db_api.session.query(CVE).all()
        if filename:
            ext = filename.split('.', maxsplit=1)[-1].lower()
            with open(filename, 'a') as f:
                if ext in ['yml', 'yaml', ]:
                    for data in self.iter(objs):
                        f.write(yaml.dump(data))
                else:
                    for data in iter(objs):
                        f.write(json.dumps(data))
                        f.write('\n')
        else:
            for data in iter(objs):
                print(dict(data))


class ExportOvalAction(Action):
    def _iter(self, objs):
        for obj in objs:
            cve = CVEAdapter(obj)
            for issue in cve.product_package_issues:
                package = issue.package
                d = {
                    'cveid': cve.name,
                    'distribution': {
                        'name': package.distribution.name,
                        'version': package.distribution.version,
                    },
                    'product_distribution': {
                        'name': package.product_distribution.name,
                        'version': package.product_distribution.version,
                    },
                    'product': {
                        'name': package.product.name,
                        'version': package.product.version,
                    },
                    'package': {
                        'name': package.source_package.name,
                        'version': package.version,
                    },
                    'binary_packages': [
                        x.name for x in package.binary_packages],
                    'affected': issue.affected,
                    'resolved': issue.resolved,
                }
                yield d

    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        objs = self.db_api.session.query(CVE).all()
        if filename:
            ext = filename.split('.', maxsplit=1)[-1].lower()
            with open(filename, 'a') as f:
                if ext in ['yml', 'yaml', ]:
                    for data in self._iter(objs):
                        f.write(yaml.dump([data, ]))
                else:
                    for data in self._iter(objs):
                        f.write(json.dumps(data))
                        f.write('\n')
        else:
            for data in iter(objs):
                print(dict(data))


class ExportSourcePackageAction(Action):
    @staticmethod
    def iter(objs):
        for obj in objs:
            pkg = SourcePackageAdapter(obj)
            yield pkg.export()

    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        objs = self.db_api.session.query(SourcePackage).all()
        if filename:
            ext = filename.split('.', maxsplit=1)[-1].lower()
            with open(filename, 'a') as f:
                if ext == 'csv':
                    fieldnames = ['project', 'package', 'origin', 'product',
                                  'distribution', 'binary_package', 'cve']
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    for d in self.iter(objs):
                        for pp in d.get('product_packages', []):
                            datarow = {}
                            datarow['project'] = pp\
                                .get('property', {})\
                                .get('source_project', '')
                            datarow['package'] = '{}-{}'.format(
                                pp.get('distribution_package', {})
                                .get('source_package', {}).get('name', ''),
                                pp.get('distribution_package', {})
                                .get('source_package', {}).get('version', '')
                            )
                            datarow['product'] = '{}-{}'.format(
                                pp.get('product', {}).get('name', ''),
                                pp.get('product', {}).get('version', '')
                            )
                            datarow['distribution'] = '{} {} {}'.format(
                                pp.get('distribution_package', {})
                                .get('distribution', {}).get('name', ''),
                                pp.get('distribution_package', {})
                                .get('distribution', {}).get('version', ''),
                                pp.get('distribution_package', {})
                                .get('distribution', {}).get('arch', ''),
                            )
                            datarow['origin'] = pp\
                                .get('source_package', {})\
                                .get('property', {})\
                                .get('origin', '')
                            datarow['cve'] = ' '.join(
                                [x['cve']['name'] for x in d.get('cves', [])]
                            )
                            for pkg in pp.get('binary_packages', ['', ]):
                                datarow['binary_package'] = pkg
                                writer.writerow(datarow)
                elif ext in ['yml', 'yaml', ]:
                    for data in iter(objs):
                        f.write(yaml.dump([dict(data), ]))
                else:
                    for data in iter(objs):
                        f.write(json.dumps(dict(data)))
                        f.write('\n')
        else:
            for data in iter(objs):
                print(dict(data))


class InitDbAction(Action):
    def take_action(self, *args, **kwargs):
        distributions = [
            {
                'name': None,
                'version': None,
                'arch': None,
                'sources': [],
                'aliases': [],
            },
            {
                'name': 'CentOS',
                'version': '6',
                'arch': None,
                'sources': [],
                'aliases': [
                    'centos6',
                ],
            },
            {
                'name': 'CentOS',
                'version': '7',
                'arch': None,
                'sources': [],
                'aliases': [
                    'centos7',
                ],
            },
            {
                'name': 'Debian',
                'version': '8.0',
                'arch': None,
                'sources': [],
                'aliases': [
                    'jessie',
                ],
            },
            {
                'name': 'RedHat',
                'version': '6',
                'arch': None,
                'sources': [],
                'aliases': [
                    'el6',
                ],
            },
            {
                'name': 'RedHat',
                'version': '7',
                'arch': None,
                'sources': [],
                'aliases': [
                    'el7',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '12.04',
                'arch': None,
                'sources': [],
                'aliases': [
                    'precise',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '14.04',
                'arch': None,
                'sources': [
                    'deb http://archive.ubuntu.com/ubuntu trusty '
                    'main restricted universe multiverse',
                    'deb http://archive.ubuntu.com/ubuntu trusty-updates '
                    'main restricted universe multiverse',
                    'deb http://archive.ubuntu.com/ubuntu trusty-backports '
                    'main restricted universe multiverse',
                    'deb http://security.ubuntu.com/ubuntu trusty-security '
                    'main restricted universe multiverse',
                ],
                'aliases': [
                    'trusty',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '14.10',
                'arch': None,
                'sources': [],
                'aliases': [
                    'utopic',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '15.04',
                'arch': None,
                'sources': [],
                'aliases': [
                    'vivid',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '15.10',
                'arch': None,
                'sources': [],
                'aliases': [
                    'wily',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '16.04',
                'arch': None,
                'sources': [
                    'deb http://archive.ubuntu.com/ubuntu xenial '
                    'main restricted universe multiverse',
                    'deb http://archive.ubuntu.com/ubuntu xenial-updates '
                    'main restricted universe multiverse',
                    'deb http://archive.ubuntu.com/ubuntu xenial-backports '
                    'main restricted universe multiverse',
                    'deb http://security.ubuntu.com/ubuntu xenial-security '
                    'main restricted universe multiverse',
                ],
                'aliases': [
                    'xenial',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '16.10',
                'arch': None,
                'sources': [],
                'aliases': [
                    'yakkety',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '17.04',
                'arch': None,
                'sources': [],
                'aliases': [
                    'zesty',
                ],
            },
        ]

        drop_database = self.mapped_args.get('drop_database', False)
        if drop_database:
            self.db_api.drop_database()
            self.db_api.create_all()

        for data in distributions:
            dist = DistributionAdapter.new(
                name=data.get('name', None),
                version=data.get('version', None),
                arch=data.get('arch', None)
            )
            for src in data.get('sources', []):
                dist.add_property(name='source_list', value=src)
            for alias in data.get('aliases', []):
                fn = dist.add_property
                fn(name='alias', value=alias)
            dist.commit()


class ScanDistributionPackageAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        dist = DistributionAdapter(**data)

        rootdir = tempfile.mkdtemp()
        cache = apt.Cache(rootdir=rootdir)
        with open(rootdir + '/etc/apt/sources.list', 'w') as f:
            for name, value in dist.properties(name='source_list'):
                f.write('{}\n'.format(value))

        # Now, lets update the package list
        cache.open(None)
        cache.update()
        # We need to re-open the cache because it needs to
        # read the package list
        cache.open(None)

        for pkg in dist.distribution_packages:
            if pkg.name not in cache:
                continue
            deb_pkg = cache[pkg.name]
            latest = deb_pkg.versions[0]
            version = DebianVersion(latest.version)
            if pkg.version == version.version:
                print("Matched package {} {}".format(pkg.name,
                                                     version.full_version))
                dist_pkg = dist.add_package(pkg.source_package,
                                            version=version.full_version)
                dist_pkg.commit()


# class ReportUnresolvedCveAction(Action):
#     def take_action(self, rootdir='.'):
#         env = Environment(
#             loader=FileSystemLoader('templates')
#         )
#
#         template = env.get_template('unresolved-cves.html')
#         join = [(ProductPackageIssue, {'resolved': False}), ]
#         objs = self.db_api.query(ProductPackage, ProductPackageAdapter,
#                                  join=join)
#         _rootdir = os.path.join(rootdir, 'html', 'reports')
#         os.makedirs(_rootdir, exist_ok=True)
#         path = os.path.join(_rootdir, 'unresolved-cves.html')
#         with open(path, 'w') as f:
#             f.write(template.render(objs=objs))


class RefreshProjectAction(Action):
    def take_action(self):
        objs = self.db_api.session.query(SourceProject).all()
        for obj in objs:
            prj = SourceProjectAdapter(obj)
            prj.refresh()
            prj.commit()


class ExportHtmlAction(Action):
    def take_action(self):
        now = datetime.datetime.now()

        self.htmldir = self.mapped_args.get('htmldir', 'html')
        self.filesdir = self.mapped_args.get('filesdir', 'files')
        self.attrs['statefile'] = self.mapped_args.get('statefile')
        self.env = Environment(
            loader=PackageLoader('cvetracker', 'templates')
        )
        self.env.globals['now'] = datetime.datetime.now
        os.makedirs(self.htmldir, exist_ok=True)

        template = self.env.get_template('style.css')
        path = os.path.join(self.htmldir, 'style.css')
        with open(path, 'w') as f:
            f.write(template.render())

        self.load_state()
        state = self.attrs.get('state')

        date_since = None
        if state is not None:
            if state.get('timestamp'):
                date_since = datetime.datetime.fromtimestamp(
                    state.get('timestamp'))
            else:
                state['timestamp'] = now.timestamp()

        self.export_distributions(date_since=date_since)
        self.export_products(date_since=date_since)
        self.export_advisories(date_since=date_since)
        self.export_cves(date_since=date_since)
        self.export_cpes(date_since=date_since)
        self.export_source_projects(date_since=date_since)
        self.export_source_packages(date_since=date_since)
        self.export_distribution_packages(date_since=date_since)
        self.export_product_packages(date_since=date_since)
        self.generate_reports()

        template = self.env.get_template('index.html')
        path = os.path.join(self.htmldir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='.'))

        self.save_state()

    def load_state(self):
        if self.attrs['statefile'] is None:
            return
        default = {'timestamp': None,}
        try:
            self.attrs['state'] = dict()
            self.attrs['state'].update(default)
            with open(self.attrs['statefile'], 'r') as f:
                state = json.load(f)
            self.attrs['state'].update(state)
        except: # noqa
            self.log.warning("Failed to load state from file '{}'"
                             .format(self.attrs['statefile']))
            self.attrs['state'] = dict()
            self.attrs['state'].update(default)

    def save_state(self):
        if self.attrs['statefile'] is None:
            return
        with open(self.attrs['statefile'], 'w') as f:
            state = json.dumps(self.attrs['state'], indent=2)
            f.write(state)

    def export_distributions(self, date_since = None):
        self.log.info("Exporting distributions ...")
        template = self.env.get_template('distribution.html')
        _rootdir = os.path.join(self.htmldir, 'distribution')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(Distribution, DistributionAdapter)
        index = []
        for obj in objs:
            index.append((str(obj), obj.id))

            if date_since:
                if obj.date_modified < date_since:
                    continue

            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('distribution-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_products(self, date_since = None):
        self.log.info("Exporting products ...")
        template = self.env.get_template('product.html')
        _rootdir = os.path.join(self.htmldir, 'product')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(Product, ProductAdapter)
        index = []
        for obj in objs:
            index.append((str(obj), obj.id))

            if date_since:
                if obj.date_modified < date_since:
                    continue

            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('product-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_advisories(self, date_since = None):
        self.log.info("Exporting advisories ...")
        template = self.env.get_template('advisory.html')
        _rootdir = os.path.join(self.htmldir, 'advisory')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(Advisory, AdvisoryAdapter)
        index = {}
        for obj in objs:
            add_to_index = False
            for cve in obj.cves:
                if len(list(cve.product_packages)):
                    add_to_index = True
                    break
            if add_to_index:
                try:
                    ts = datetime.datetime.fromtimestamp(
                        float(obj.get_property(
                            'released_on', as_scalar=True).value))
                    l1_key = tuple(ts.strftime('%Y %m %b').split(' '))
                except Exception as e:
                    self.log.error("Failed to get released_on timestamp for {}"
                                   .format(obj.name))
                    self.log.error(e)
                    l1_key = ('', '', '')
                match = re.match(r'^(USN|RH.A)-.*$', obj.name)
                if match:
                    l2_key = match.group(1)
                else:
                    l2_key = ''
                index.setdefault(l1_key, {})\
                    .setdefault(l2_key, [])\
                    .append((obj.name, obj.id))

            if date_since:
                if obj.date_modified < date_since:
                    continue

            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('advisory-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_cves(self, date_since = None):
        self.log.info("Exporting CVEs ...")
        template = self.env.get_template('cve.html')
        _rootdir = os.path.join(self.htmldir, 'cve')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(CVE, CVEAdapter)
        index = {}
        for obj in objs:
            parts = obj.name.upper().split('-', maxsplit=2)
            if parts[0] == 'CVE':
                index.setdefault(parts[0], {})\
                    .setdefault(parts[1], {})\
                    .setdefault(parts[2][:1], [])\
                    .append((obj.name, obj.id))

            if date_since:
                if obj.date_modified < date_since:
                    continue

            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('cve-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_cpes(self, date_since = None):
        self.log.info("Exporting CPEs ...")
        template = self.env.get_template('cpe.html')
        _rootdir = os.path.join(self.htmldir, 'cpe')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(CPE, CPEAdapter)
        index = []
        for obj in objs:
            index.append((obj.wfn.bind_to_fs(), obj.id))

            if date_since:
                if obj.date_modified < date_since:
                    continue

            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('cpe-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_source_projects(self, date_since = None):
        self.log.info("Exporting source projects ...")
        template = self.env.get_template('source-project.html')
        _rootdir = os.path.join(self.htmldir, 'source-project')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(SourceProject, SourceProjectAdapter)
        index = dict()
        for obj in objs:
            index_letter = str(obj.name)[0].upper()
            index.setdefault(index_letter, list()).append(obj)

            if date_since:
                if obj.date_modified < date_since:
                    continue

            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('source-project-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_source_packages(self, date_since = None):
        self.log.info("Exporting source packages ...")
        template = self.env.get_template('source-package.html')
        _rootdir = os.path.join(self.htmldir, 'source-package')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(SourcePackage, SourcePackageAdapter)
        index = dict()
        for obj in objs:
            index_letter = str(obj.name)[0].upper()
            index.setdefault(index_letter, dict())\
                .setdefault(obj.name, list())\
                .append(obj)

            if date_since:
                if obj.date_modified < date_since:
                    continue

            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('source-package-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_distribution_packages(self, date_since = None):
        self.log.info("Exporting distribution packages ...")
        template = self.env.get_template('distribution-package.html')
        _rootdir = os.path.join(self.htmldir, 'distribution-package')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(DistributionPackage,
                                 DistributionPackageAdapter)
        index = {}
        for obj in objs:
            index_letter = str(obj.name)[0].upper()
            index.setdefault(index_letter, []).append(obj)

            if date_since:
                if obj.date_modified < date_since:
                    continue

            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('distribution-package-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_product_packages(self, date_since = None):
        self.log.info("Exporting product packages ...")
        template = self.env.get_template('product-package.html')
        _rootdir = os.path.join(self.htmldir, 'product-package')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(ProductPackage, ProductPackageAdapter)
        index = dict()
        for obj in objs:
            product_name = str(obj.product)
            package_name = obj.name
            index.setdefault(product_name, {})\
                .setdefault(package_name[0].upper(), [])\
                .append(obj)

            if date_since:
                if obj.date_modified < date_since:
                    continue

            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('product-package-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def generate_reports(self):
        self.log.info("Generating reports ...")
        template = self.env.get_template('unresolved-cves.html')
        objs = self.db_api.query(ProductPackage, ProductPackageAdapter)
        data = {
            'stat': {},
            'objs': {},
        }
        for x in objs:
            related_issues = x.related_issues(merge=True)
            if len(related_issues) == 0:
                continue
            product_name = str(x.product)
            stat = data['stat'].setdefault(product_name, {})
            stat.setdefault('affected', list())
            stat.setdefault('resolved', list())
            stat.setdefault('packages', set())
            _related_issues = dict()
            for key, value in related_issues.items():
                is_tracked = value['tracked']
                issues = value['issues']
                _issues = list()
                if is_tracked:
                    for item in issues:
                        if item['issue'].affected:
                            stat['affected'].append(key)
                            if item['issue'].resolved:
                                stat['resolved'].append(key)
                            else:
                                _issues.append(item)
                else:
                    direct = False
                    for item in issues:
                        if item['direct']:
                            direct = True
                            if item['issue'].affected:
                                _issues.append(item)
                                stat['affected'].append(key)
                            break
                    if not direct:
                        for item in issues:
                            _issues.append(item)
                            stat['affected'].append(key)
                if _issues:
                    _related_issues[key] = (is_tracked, _issues)
            if _related_issues:
                stat['packages'].add(x)
                key = '{}-{}'.format(x.name, x.version)
                data['objs'].setdefault(product_name, dict())\
                    .setdefault(key, list()).append((x, _related_issues))

        _rootdir = os.path.join(self.htmldir, 'reports')
        os.makedirs(_rootdir, exist_ok=True)
        path = os.path.join(_rootdir, 'unresolved-cves.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', data=data))

        template = self.env.get_template('reports-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..'))

        _rootdir = os.path.join(self.filesdir, 'reports')
        os.makedirs(_rootdir, exist_ok=True)
        path = os.path.join(_rootdir, 'unresolved-cves.csv')
        with open(path, 'w') as csvfile:
            fieldnames = ['project', 'version', 'product', 'distribution',
                          'cve', 'cvss_v2', 'cvss_v3', 'affected', 'resolved']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()

            for product_name, product_packages in data['objs'].items():
                for package_name, package_issues in product_packages.items():
                    for product_package, related_issues in package_issues:
                        for cve_number, (tracked, issues) in \
                                related_issues.items():
                            issue = issues[0]
                            row = {
                                'project': product_package.source_package.name,
                                'version':
                                    product_package.source_package.version,
                                'product': product_name,
                                'distribution':
                                    str(product_package.product_distribution),
                                'cve': cve_number,
                            }
                            cve = issue['issue'].issue
                            cvss = cve.cvss2
                            row['cvss_v2'] = cvss.base_score if cvss else '0.0'
                            cvss = cve.cvss3
                            row['cvss_v3'] = cvss.base_score if cvss else '0.0'
                            if tracked:
                                row.update({
                                    'affected': issue['issue'].affected,
                                    'resolved': issue['issue'].resolved,
                                })
                            else:
                                if issue['direct']:
                                    row.update({
                                        'affected': issue['issue'].affected,
                                        'resolved': False,
                                    })
                                else:
                                    row.update({
                                        'affected': True,
                                        'resolved': False
                                    })
                            writer.writerow(row)


class ExportRecentlyUpdatedAction(Action):
    def take_action(self):
        now = datetime.datetime.now()

        for attr in ['filesdir', 'filename', 'statefile']:
            if attr in self.mapped_args:
                self.attrs[attr] = self.mapped_args[attr]

        assert self.attrs['filesdir'], "'filesdir' is not set or empty"

        self.attrs.setdefault(
            'filename',
            os.path.join(self.attrs['filesdir'], 'recently-updated.json')
        )

        self.attrs.setdefault(
            'statefile',
            os.path.join(self.attrs['filesdir'], 'recently-updated.state')
        )

        for attr in ['filename', 'statefile']:
            assert self.attrs[attr], "'{}' is not set or empty".format(attr)

        self.attrs['env'] = Environment(
            loader=PackageLoader('cvetracker', 'templates')
        )
        os.makedirs(self.attrs['filesdir'], exist_ok=True)

        self.load_state()
        timestamp = self.attrs['state'].get('timestamp')
        if timestamp is None:
            self.log.warning("Timestamp from previous run was not set")
            self.attrs['state']['timestamp'] = now.timestamp()
            self.save_state()
            return

        date_since = datetime.datetime.fromtimestamp(float(timestamp))
        data = self.recently_updated(date_since)
        self.generate_json(data)
        # self.send_email_notification(data)

        self.attrs['state']['timestamp'] = now.timestamp()
        self.save_state()

    def load_state(self):
        self.attrs['state'] = {
            'timestamp': None,
        }
        try:
            with open(self.attrs['statefile'], 'r') as f:
                state = json.load(f)
                self.attrs['state'].update(state)
        except: # noqa
            self.log.warning("Failed to load state from file '{}'"
                             .format(self.attrs['statefile']))

    def save_state(self):
        with open(self.attrs['statefile'], 'w') as f:
            json.dump(self.attrs['state'], f, indent=2)

    def recently_updated(self, date_since):
        data = dict()

        self.log.info("Searching by SourcePackageIssue.date_modified ...")
        count = 0
        query = self.db_api.session.query(SourcePackageIssue)\
            .filter(SourcePackageIssue.date_modified > date_since)
        for x in query.all():
            obj = SourcePackageIssueAdapter(x)
            for pkg in obj.package.product_packages:
                data.setdefault(obj.issue, dict())\
                    .setdefault(pkg, list())\
                    .append(RelatedIssueAdapter(obj, pkg))
                count += 1
        self.log.info("{} record(s) added".format(count))

        self.log.info("Searching by DistributionPackageIssue.date_modified "
                      "...")
        count = 0
        query = self.db_api.session.query(DistributionPackageIssue)\
            .filter(DistributionPackageIssue.date_modified > date_since)
        for x in query.all():
            obj = DistributionPackageIssueAdapter(x)
            for pkg in obj.package.product_packages:
                data.setdefault(obj.issue, dict())\
                    .setdefault(pkg, list())\
                    .append(RelatedIssueAdapter(obj, pkg))
                count += 1
        self.log.info("{} record(s) added".format(count))

        self.log.info("Searching by ProductPackageIssue.date_modified ...")
        count = 0
        query = self.db_api.session.query(ProductPackageIssue)\
            .filter(ProductPackageIssue.date_modified > date_since)
        for x in query.all():
            obj = ProductPackageIssueAdapter(x)
            data.setdefault(obj.issue, dict())\
                .setdefault(obj.package, list())\
                .append(obj)
            count += 1
        self.log.info("{} record(s) added".format(count))

        self.log.info("{} unique recodrs found".format(len(data)))

        result = list()
        for issue, packages in data.items():
            for _, issues in packages.items():
                result.append(issues[-1])

        return sorted(result, key=lambda x: x.date_modified, reverse=True)

    def generate_json(self, data):
        out = []
        for item in data:
            x = item.dict()
            out.append(x)

        with open(self.attrs['filename'], 'w') as f:
            for x in out:
                f.write(json.dumps(x))

    def send_email_notification(self, data):
        self.log.info("Sending e-mail notification ...")

        _data = [x for x in data if (x.affected and not x.resolved)]

        if len(_data) == 0:
            self.log.info("No data to send notification, skipping ...")
            return

        conf = CONFIG.config
        from_addr = conf.get('smtp', 'from-address')
        from_name = conf.get('smtp', 'from-name')
        to_addr = conf.get('smtp', 'to-address')

        self.log.info("Preparing e-mail attachment ...")
        fieldnames = ['Package', 'Version', 'Product', 'Distribution', 'Type',
                      'Issue', 'Affected', 'Resolved', 'Modified']
        csvfile = os.path.join(self.attrs['filesdir'],
                                'vulnerable-packages.csv')
        with open(csvfile, 'w') as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            for x in _data:
                row = {
                    'Package': x.package.name,
                    'Version': x.package.version,
                    'Product': x.package.get('product'),
                    'Distribution': x.package.get('distribution'),
                    'Type': x.model_name,
                    'Issue': x.issue.name,
                    'Affected': x.affected,
                    'Resolved': x.resolved,
                    'Modified': x.date_modified
                }
                writer.writerow(row)

        self.log.info("Preparing e-mail body ...")
        template = self.attrs['env'].get_template(
            'vulnerable-packages-email.html')
        message = template.render(data=_data[:50])

        self.log.info("Sending e-mail ...")
        email = EmailHelper()
        msg = EmailMessage()
        msg.field_from(from_addr, from_name)
        msg.field_to(to_addr)
        msg.subject('Vulnerable Packages ({})'.format(len(_data)))
        msg.body(message, 'html')
        msg.attach_file(csvfile)
        email.send(msg)


class SendEmailAction(Action):
    def take_action(self):
        for attr in ['changes', 'recent', 'filesdir']:
            self.attrs[attr] = self.mapped_args.get(attr)

        self.attrs['env'] = Environment(
            loader=PackageLoader('cvetracker', 'templates')
        )
        os.makedirs(self.attrs['filesdir'], exist_ok=True)

        self.log.info("Sending e-mail notification ...")

        changes = dict()
        with open(self.attrs['changes']) as f:
            for line in f:
                x = json.loads(line)
                changes[x['item']['id']] = x

        recent = dict()
        with open(self.attrs['recent']) as f:
            for line in f:
                x = json.loads(line)
                if x['affected'] and not x['resolved']:
                    recent[x['id']] = x

        if len(changes):
            template = {
                'description': 'The following packages were detected as fixed '
                               'during last CVE tracker run. Information on '
                               'CVEs related is on the next page.'
            }
            msagen = MSAGenerator(template=template)
            msa = msagen.make_pdf(changes.values(), '0001')
            msafile = os.path.join(self.attrs['filesdir'], 'msa.pdf')
            with open(msafile, 'wb') as f:
                f.write(msa.getvalue())
        else:
            msafile = None

        data = list()
        for k, x in recent.items():
            if k in changes:
                continue
            row = {
                'Package': x['package']['source_package']['project']['name'],
                'Version': x['package']['version'],
                'Product': '{0[name]}-{0[version]}'
                    .format(x['package']['product']),
                'Distribution': '{0[name]}-{0[version]}'
                    .format(x['package']['product_distribution']),
                'Type': x['__model__'],
                'Issue': x['issue']['name'],
                'Affected': x['affected'],
                'Affected (pre)': '',
                'Resolved': x['resolved'],
                'Resolved (pre)': '',
                'Modified': x['date_modified'],
            }
            data.append(row)

        for x in changes.values():
            y = {
                'affected': '',
                'resolved': '',
            }
            y[x['attr']] = x['value']
            x = x['item']
            row = {
                'Package': x['package']['source_package']['project']['name'],
                'Version': x['package']['version'],
                'Product': '{0[name]}-{0[version]}'
                    .format(x['package']['product']),
                'Distribution': '{0[name]}-{0[version]}'
                    .format(x['package']['product_distribution']),
                'Type': x['__model__'],
                'Issue': x['issue']['name'],
                'Affected': x['affected'],
                'Affected (pre)': y['affected'],
                'Resolved': x['resolved'],
                'Resolved (pre)': y['resolved'],
                'Modified': x['date_modified'],
            }
            data.append(row)

        if not len(data):
            self.log.info("No data to send email notifications")
            return

        self.log.info("Preparing CSV attachment ...")
        fieldnames = ['Package', 'Version', 'Product', 'Distribution', 'Type',
                      'Issue', 'Affected', 'Affected (pre)', 'Resolved',
                      'Resolved (pre)', 'Modified']
        csvfile = os.path.join(self.attrs['filesdir'],
                               'vulnerable-packages.csv')
        with open(csvfile, 'w') as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            for row in data:
                writer.writerow(row)

        self.log.info("Preparing e-mail body ...")
        template = self.attrs['env'].get_template(
            'vulnerable-packages-email.html')
        message = template.render(data=data[:50])

        self.log.info("Sending e-mail ...")
        conf = CONFIG.config
        from_addr = conf.get('smtp', 'from-address')
        from_name = conf.get('smtp', 'from-name')
        to_addr = conf.get('smtp', 'to-address')

        email = EmailHelper()
        msg = EmailMessage()
        msg.field_from(from_addr, from_name)
        msg.field_to(to_addr)
        msg.subject('Vulnerable Packages ({})'.format(len(data)))
        msg.body(message, 'html')
        msg.attach_file(csvfile)
        if msafile:
            msg.attach_file(msafile)
        email.send(msg)


class ApplyCpeOverridesAction(Action):
    def take_action(self):
        data = self.mapped_args
        path = data.get('path', None)
        config = ConfigDir(path)
        for key in config:
            data = config.get(key)
            meta = data.pop('__meta__')
            if meta['is_empty']:
                continue
            cpe_parts = dict(zip(meta['schema'], meta['key']))
            if not cpe_parts:
                continue

            cpe = CPEAdapter.new(
                part=cpe_parts.get('part'),
                vendor=cpe_parts.get('vendor'),
                product=cpe_parts.get('product'),
            )
            self.log.info("Processing CPE {}".format(str(cpe.wfn)))

            for project_data in data.get('projects', []):
                try:
                    project = SourceProjectAdapter(
                        name=project_data.get('name'),
                        type=project_data.get('type'),
                    )
                    self.log.info("- adding project {}".format(str(project)))
                    project.add_cpe(cpe)
                    project.commit()
                except: # noqa
                    self.log.warning(
                        "No project matchin '{}'".format(project_data))

        GenericAdapter.flush_changes(data.get('changes'))


class ApplyCveOverridesAction(Action):
    def take_action(self):
        data = self.mapped_args
        path = data.get('path', None)
        config = ConfigDir(path)
        for elements in config:
            self._update_cves(config, elements)

        GenericAdapter.flush_changes(data.get('changes'))

    def _build_query(self, rule):
        query = None
        adapter = None

        # Build query object
        filter_by = rule.get('product')
        if filter_by:
            query = self.db_api.session.query(ProductPackage) \
                .join(DistributionPackage) \
                .join(Product) \
                .join(SourcePackage)
            adapter = ProductPackageAdapter

        filter_by = rule.get('distribution')
        if filter_by:
            if query is None:
                query = self.db_api.session \
                    .query(DistributionPackage)
                adapter = DistributionPackageAdapter

            query = query \
                .join(Distribution).join(SourcePackage)

        if query is None:
            query = self.db_api.session.query(SourcePackage)
            adapter = SourcePackageAdapter

        query = query.join(SourceProject)

        return query, adapter

    def _add_filter(self, query, rule):
        # Add filters
        filter_by = rule.get('package')
        if filter_by:
            filter_by_item = filter_by.get('name', '*')
            if filter_by_item != '*':
                query = query.filter(
                    SourceProject.name == filter_by_item)

            filter_by_item = filter_by.get('version', '*')
            if filter_by_item != '*':
                query = query.filter(
                    SourcePackage.version == filter_by_item)

        filter_by = rule.get('product')
        if filter_by:
            filter_by_item = filter_by.get('name', '*')
            if filter_by_item != '*':
                query = query.filter(
                    Product.name == filter_by_item)

            filter_by_item = filter_by.get('version', '*')
            if filter_by_item != '*':
                query = query.filter(
                    Product.version == filter_by_item)

        filter_by = rule.get('distribution')
        if filter_by:
            filter_by_item = filter_by.get('name', '*')
            if filter_by_item != '*':
                query = query.filter(
                    Distribution.name == filter_by_item)

            filter_by_item = filter_by.get('version', '*')
            if filter_by_item != '*':
                query = query.filter(
                    Distribution.version == filter_by_item)

        return query

    def _update_cve(self, package, cve_number, cve_status):
        cve = CVEAdapter.new(name=cve_number)
        kwargs = {}
        for key in ('affected', 'resolved'):
            if key in cve_status:
                try:
                    kwargs[key] = to_bool(cve_status[key])
                except: # noqa
                    pass
        package.add_cve(cve, **kwargs)

    def _update_cves(self, config, elements):
        try:
            name, version = elements
            rules = config.get(elements).get('rules', [])
            for rule in rules:
                cves = rule.get('cve')
                if cves is None:
                    self.log.error("No cve section in '{}' rule '{}'"
                                   .format('|'.join(elements), rule))
                    continue

                rule.update({
                    'package': {
                        'name': name,
                        'version': version,
                    }
                })
                self.log.debug("Updating {} following rule {}"
                               .format('|'.join(elements), rule))
                query, adapter = self._build_query(rule)
                query = self._add_filter(query, rule)

                # Build CVE data
                cve_data = {}
                for cve_year, cve_numbers in cves.items():
                    for cve_number, cve_status in cve_numbers.items():
                        if cve_year == '*':
                            cve_name = '*'
                        else:
                            cve_name = 'CVE-{}-{}'.format(cve_year, cve_number)
                        cve_data[cve_name] = cve_status

                # Update CVEs
                cve_status = cve_data.get('*')
                if cve_status:
                    for x in query.all():
                        y = adapter(x)
                        related_issues = y.related_issues(merge=True)
                        for cve_number in related_issues:
                            self._update_cve(y, cve_number, cve_status)
                else:
                    for x in query.all():
                        y = adapter(x)
                        related_issues = y.related_issues(merge=True)
                        for cve_number in related_issues:
                            cve_status = cve_data.get(cve_number)
                            if cve_status:
                                self._update_cve(y, cve_number, cve_status)

                self.db_api.session.commit()
        except: # noqa
            self.log.exception("Something went wrong")


class UpdateSourceProjectAction(Action):
    def take_action(self):
        if 'id' in self.mapped_args:
            prj = SourceProjectAdapter(id=self.mapped_args.get('id'))
        elif 'name' in self.mapped_args:
            prj = SourceProjectAdapter(name=self.mapped_args.get('name'))
        else:
            raise Exception("Need id or name to load source project")

        if 'link_cpe' in self.mapped_args:
            wfn = CpeWFN(self.mapped_args.get('link_cpe'))
            prj.add_cpe_wfn(wfn)
            prj.commit()


class ListSourceProjectAction(Action):
    def take_action(self):
        objs = self.db_api.query(SourceProject, SourceProjectAdapter)
        if 'name' in self.mapped_args:
            name = self.mapped_args['name']
            for x in objs:
                if x.name == name:
                    yield x
        elif 'cpe' in self.mapped_args:
            wfn = CpeWFN(self.mapped_args['cpe'])
            _kwargs = dict()
            for key in ('part', 'vendor', 'product'):
                if wfn.get(key).is_string:
                    _kwargs[key] = str(wfn.get(key))
            cpes = self.db_api.query(CPE, CPEAdapter, filter_by=_kwargs)
            for cpe in cpes:
                for x in cpe.projects:
                    yield x
        else:
            for x in objs:
                yield x
