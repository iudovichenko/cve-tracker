
import csv
import datetime
import json
import logging
import os
import re
import tempfile

import apt
import yaml
from configdir import ConfigDir
from jinja2 import Environment, PackageLoader

from cvetracker.cpe import CpeWFN

from cvetracker.db.adapters import AdvisoryAdapter
from cvetracker.db.adapters import CPEAdapter
from cvetracker.db.adapters import CVEAdapter
from cvetracker.db.adapters import DistributionAdapter
from cvetracker.db.adapters import DistributionPackageAdapter
from cvetracker.db.adapters import ProductAdapter
from cvetracker.db.adapters import ProductPackageAdapter
from cvetracker.db.adapters import SourcePackageAdapter
from cvetracker.db.adapters import SourceProjectAdapter

from cvetracker.db.api import DBAPI

from cvetracker.db.models import Advisory
from cvetracker.db.models import CPE
from cvetracker.db.models import CVE
from cvetracker.db.models import Distribution
from cvetracker.db.models import DistributionPackage
from cvetracker.db.models import Product
from cvetracker.db.models import ProductPackage
# from cvetracker.db.models import ProductPackageIssue
from cvetracker.db.models import SourcePackage
from cvetracker.db.models import SourceProject

from cvetracker.misc import DebianVersion
from cvetracker.nvd_feed import Node

re_bool_true = re.compile(r'^(1|true|yes)$', re.IGNORECASE)
re_bool_false = re.compile(r'^(0|false|no)$', re.IGNORECASE)


def to_bool(string):
    if re_bool_true.match(string):
        return True
    if re_bool_false.match(string):
        return False
    raise Exception("Can't cast string '{}' to bool".format(string))


def map_parsed_args(parsed_args, args_map):
    d = {}
    for arg, key in args_map.items():
        value = getattr(parsed_args, arg, None)
        if value:
            d[key] = value
    return d


class Action(object):
    log = logging.getLogger(__name__)

    def __init__(self, parsed_args=None, args_map=None):
        self.db_api = DBAPI()

        if args_map is None:
            args_map = {}

        if parsed_args is None:
            self.mapped_args = {}
        else:
            self.mapped_args = map_parsed_args(parsed_args, args_map)

    def take_action(self):
        raise Exception("Not implemented")


class ImportAdvisoryAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        self.log.info("Importing advisory data from '{}'".format(filename))

        count = 0
        with open(filename) as f:
            adv_list = json.load(f)

            for adv_name, adv_data in adv_list.get('resolved', {}).items():
                count += 1

                adv = AdvisoryAdapter.new(name=adv_name)
                adv.update(adv_data)
                adv.commit()

        self.log.info('Import done. Imported {} advisory object(s).'
                      .format(count))


class ImportCPEAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        self.log.info("Importing CPE data from '{}'".format(filename))

        count = 0
        with open(filename) as f:
            for line in f:
                count += 1
                wfn = CpeWFN(line.strip().replace('"', ''))
                try:
                    cpe = CPEAdapter.new(
                        part=str(wfn.get('part')),
                        vendor=str(wfn.get('vendor')),
                        product=str(wfn.get('product')),
                    )
                    cpe.commit()
                except Exception as e:
                    self.log.exception(e)

        self.log.info('Import done. Imported {} package object(s).'
                      .format(count))


class ImportFeedAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        self.log.info("Importing feed from '{}'".format(filename))

        with open(filename) as f:
            count = 0
            feed = json.load(f)
            cve_items = list()
            if isinstance(feed, list):
                cve_items = feed
            if isinstance(feed, dict):
                cve_items = feed.get('CVE_Items', list())
            for item in cve_items:
                nodes = item.get('configurations', dict()).get('nodes', list())
                for node_data in nodes:
                    count += 1

                    impact = item.get('impact', {})
                    cvss_v2_vector = impact.get('baseMetricV2', {}) \
                        .get('cvssV2', {}).get('vectorString')
                    cvss_v3_vector = impact.get('baseMetricV3', {}) \
                        .get('cvssV3', {}).get('vectorString')

                    cve = CVEAdapter.from_nvd(item['cve'])
                    cve.set('cvss_v2', cvss_v2_vector)
                    cve.set('cvss_v3', cvss_v3_vector)
                    cve.commit()

                    node = Node(node_data)
                    result = node.evaluate()
                    if result.data:
                        for package in result.data:
                            package.add_cve(cve)
                            package.commit()

        self.log.info('Import done. Imported {} feed item(s).'
                      .format(count))


class ImportPackageAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        self.log.info("Importing packages data from '{}'".format(filename))

        count = 0
        with open(filename) as f:
            for line in f:
                count += 1
                data = json.loads(line)
                ProductPackageAdapter.update(data)

        self.log.info('Import done. Imported {} package object(s).'
                      .format(count))


class ExportCveAction(Action):
    @staticmethod
    def iter(objs):
        for obj in objs:
            cve = CVEAdapter(obj)
            yield cve.export()

    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        objs = self.db_api.session.query(CVE).all()
        if filename:
            ext = filename.split('.', maxsplit=1)[-1].lower()
            with open(filename, 'a') as f:
                if ext in ['yml', 'yaml', ]:
                    for data in self.iter(objs):
                        f.write(yaml.dump(data))
                else:
                    for data in iter(objs):
                        f.write(json.dumps(data))
                        f.write('\n')
        else:
            for data in iter(objs):
                print(dict(data))


class ExportOvalAction(Action):
    def _iter(self, objs):
        for obj in objs:
            cve = CVEAdapter(obj)
            for issue in cve.product_package_issues:
                package = issue.package
                d = {
                    'cveid': cve.name,
                    'distribution': {
                        'name': package.distribution.name,
                        'version': package.distribution.version,
                    },
                    'product_distribution': {
                        'name': package.product_distribution.name,
                        'version': package.product_distribution.version,
                    },
                    'product': {
                        'name': package.product.name,
                        'version': package.product.version,
                    },
                    'package': {
                        'name': package.source_package.name,
                        'version': package.version,
                    },
                    'binary_packages': [
                        x.name for x in package.binary_packages],
                    'affected': issue.affected,
                    'resolved': issue.resolved,
                }
                yield d

    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        objs = self.db_api.session.query(CVE).all()
        if filename:
            ext = filename.split('.', maxsplit=1)[-1].lower()
            with open(filename, 'a') as f:
                if ext in ['yml', 'yaml', ]:
                    for data in self._iter(objs):
                        f.write(yaml.dump([data, ]))
                else:
                    for data in self._iter(objs):
                        f.write(json.dumps(data))
                        f.write('\n')
        else:
            for data in iter(objs):
                print(dict(data))


class ExportSourcePackageAction(Action):
    @staticmethod
    def iter(objs):
        for obj in objs:
            pkg = SourcePackageAdapter(obj)
            yield pkg.export()

    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        filename = data['filename']
        objs = self.db_api.session.query(SourcePackage).all()
        if filename:
            ext = filename.split('.', maxsplit=1)[-1].lower()
            with open(filename, 'a') as f:
                if ext == 'csv':
                    fieldnames = ['project', 'package', 'origin', 'product',
                                  'distribution', 'binary_package', 'cve']
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    for d in self.iter(objs):
                        for pp in d.get('product_packages', []):
                            datarow = {}
                            datarow['project'] = pp\
                                .get('property', {})\
                                .get('source_project', '')
                            datarow['package'] = '{}-{}'.format(
                                pp.get('distribution_package', {})
                                .get('source_package', {}).get('name', ''),
                                pp.get('distribution_package', {})
                                .get('source_package', {}).get('version', '')
                            )
                            datarow['product'] = '{}-{}'.format(
                                pp.get('product', {}).get('name', ''),
                                pp.get('product', {}).get('version', '')
                            )
                            datarow['distribution'] = '{} {} {}'.format(
                                pp.get('distribution_package', {})
                                .get('distribution', {}).get('name', ''),
                                pp.get('distribution_package', {})
                                .get('distribution', {}).get('version', ''),
                                pp.get('distribution_package', {})
                                .get('distribution', {}).get('arch', ''),
                            )
                            datarow['origin'] = pp\
                                .get('source_package', {})\
                                .get('property', {})\
                                .get('origin', '')
                            datarow['cve'] = ' '.join(
                                [x['cve']['name'] for x in d.get('cves', [])]
                            )
                            for pkg in pp.get('binary_packages', ['', ]):
                                datarow['binary_package'] = pkg
                                writer.writerow(datarow)
                elif ext in ['yml', 'yaml', ]:
                    for data in iter(objs):
                        f.write(yaml.dump([dict(data), ]))
                else:
                    for data in iter(objs):
                        f.write(json.dumps(dict(data)))
                        f.write('\n')
        else:
            for data in iter(objs):
                print(dict(data))


class InitDbAction(Action):
    def take_action(self, *args, **kwargs):
        distributions = [
            {
                'name': None,
                'version': None,
                'arch': None,
                'sources': [],
                'aliases': [],
            },
            {
                'name': 'CentOS',
                'version': '6',
                'arch': None,
                'sources': [],
                'aliases': [
                    'centos6',
                ],
            },
            {
                'name': 'CentOS',
                'version': '7',
                'arch': None,
                'sources': [],
                'aliases': [
                    'centos7',
                ],
            },
            {
                'name': 'Debian',
                'version': '8.0',
                'arch': None,
                'sources': [],
                'aliases': [
                    'jessie',
                ],
            },
            {
                'name': 'RedHat',
                'version': '6',
                'arch': None,
                'sources': [],
                'aliases': [
                    'el6',
                ],
            },
            {
                'name': 'RedHat',
                'version': '7',
                'arch': None,
                'sources': [],
                'aliases': [
                    'el7',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '12.04',
                'arch': None,
                'sources': [],
                'aliases': [
                    'precise',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '14.04',
                'arch': None,
                'sources': [
                    'deb http://archive.ubuntu.com/ubuntu trusty '
                    'main restricted universe multiverse',
                    'deb http://archive.ubuntu.com/ubuntu trusty-updates '
                    'main restricted universe multiverse',
                    'deb http://archive.ubuntu.com/ubuntu trusty-backports '
                    'main restricted universe multiverse',
                    'deb http://security.ubuntu.com/ubuntu trusty-security '
                    'main restricted universe multiverse',
                ],
                'aliases': [
                    'trusty',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '14.10',
                'arch': None,
                'sources': [],
                'aliases': [
                    'utopic',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '15.04',
                'arch': None,
                'sources': [],
                'aliases': [
                    'vivid',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '15.10',
                'arch': None,
                'sources': [],
                'aliases': [
                    'wily',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '16.04',
                'arch': None,
                'sources': [
                    'deb http://archive.ubuntu.com/ubuntu xenial '
                    'main restricted universe multiverse',
                    'deb http://archive.ubuntu.com/ubuntu xenial-updates '
                    'main restricted universe multiverse',
                    'deb http://archive.ubuntu.com/ubuntu xenial-backports '
                    'main restricted universe multiverse',
                    'deb http://security.ubuntu.com/ubuntu xenial-security '
                    'main restricted universe multiverse',
                ],
                'aliases': [
                    'xenial',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '16.10',
                'arch': None,
                'sources': [],
                'aliases': [
                    'yakkety',
                ],
            },
            {
                'name': 'Ubuntu',
                'version': '17.04',
                'arch': None,
                'sources': [],
                'aliases': [
                    'zesty',
                ],
            },
        ]

        drop_database = self.mapped_args.get('drop_database', False)
        if drop_database:
            self.db_api.drop_database()
            self.db_api.create_all()

        for data in distributions:
            dist = DistributionAdapter.new(
                name=data.get('name', None),
                version=data.get('version', None),
                arch=data.get('arch', None)
            )
            for src in data.get('sources', []):
                dist.add_property(name='source_list', value=src)
            for alias in data.get('aliases', []):
                fn = dist.add_property
                fn(name='alias', value=alias)
            dist.commit()


class ScanDistributionPackageAction(Action):
    def take_action(self, data=None):
        if data is None:
            data = self.mapped_args

        dist = DistributionAdapter(**data)

        rootdir = tempfile.mkdtemp()
        cache = apt.Cache(rootdir=rootdir)
        with open(rootdir + '/etc/apt/sources.list', 'w') as f:
            for name, value in dist.properties(name='source_list'):
                f.write('{}\n'.format(value))

        # Now, lets update the package list
        cache.open(None)
        cache.update()
        # We need to re-open the cache because it needs to
        # read the package list
        cache.open(None)

        for pkg in dist.distribution_packages:
            if pkg.name not in cache:
                continue
            deb_pkg = cache[pkg.name]
            latest = deb_pkg.versions[0]
            version = DebianVersion(latest.version)
            if pkg.version == version.version:
                print("Matched package {} {}".format(pkg.name,
                                                     version.full_version))
                dist_pkg = dist.add_package(pkg.source_package,
                                            version=version.full_version)
                dist_pkg.commit()


# class ReportUnresolvedCveAction(Action):
#     def take_action(self, rootdir='.'):
#         env = Environment(
#             loader=FileSystemLoader('templates')
#         )
#
#         template = env.get_template('unresolved-cves.html')
#         join = [(ProductPackageIssue, {'resolved': False}), ]
#         objs = self.db_api.query(ProductPackage, ProductPackageAdapter,
#                                  join=join)
#         _rootdir = os.path.join(rootdir, 'html', 'reports')
#         os.makedirs(_rootdir, exist_ok=True)
#         path = os.path.join(_rootdir, 'unresolved-cves.html')
#         with open(path, 'w') as f:
#             f.write(template.render(objs=objs))


class RefreshProjectAction(Action):
    def take_action(self):
        objs = self.db_api.session.query(SourceProject).all()
        for obj in objs:
            prj = SourceProjectAdapter(obj)
            prj.refresh()
            prj.commit()


class ExportHtmlAction(Action):
    def take_action(self):
        self.htmldir = self.mapped_args.get('htmldir', 'html')
        self.filesdir = self.mapped_args.get('filesdir', 'files')
        self.env = Environment(
            loader=PackageLoader('cvetracker', 'templates')
        )
        self.env.globals['now'] = datetime.datetime.now
        os.makedirs(self.htmldir, exist_ok=True)

        template = self.env.get_template('style.css')
        path = os.path.join(self.htmldir, 'style.css')
        with open(path, 'w') as f:
            f.write(template.render())

        self.export_distributions()
        self.export_products()
        self.export_advisories()
        self.export_cves()
        self.export_cpes()
        self.export_source_projects()
        self.export_source_packages()
        self.export_distribution_packages()
        self.export_product_packages()
        self.generate_reports()

        template = self.env.get_template('index.html')
        path = os.path.join(self.htmldir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='.'))

    def export_distributions(self):
        self.log.info("Exporting distributions ...")
        template = self.env.get_template('distribution.html')
        _rootdir = os.path.join(self.htmldir, 'distribution')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(Distribution, DistributionAdapter)
        index = []
        for obj in objs:
            index.append((str(obj), obj.id))
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('distribution-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_products(self):
        self.log.info("Exporting products ...")
        template = self.env.get_template('product.html')
        _rootdir = os.path.join(self.htmldir, 'product')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(Product, ProductAdapter)
        index = []
        for obj in objs:
            index.append((str(obj), obj.id))
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('product-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_advisories(self):
        self.log.info("Exporting advisories ...")
        template = self.env.get_template('advisory.html')
        _rootdir = os.path.join(self.htmldir, 'advisory')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(Advisory, AdvisoryAdapter)
        index = {}
        for obj in objs:
            add_to_index = False
            for cve in obj.cves:
                if len(list(cve.product_packages)):
                    add_to_index = True
                    break
            if add_to_index:
                try:
                    ts = datetime.datetime.fromtimestamp(
                        float(obj.get_property(
                            'released_on', as_scalar=True).value))
                    l1_key = tuple(ts.strftime('%Y %m %b').split(' '))
                except Exception as e:
                    self.log.error("Failed to get released_on timestamp for {}"
                                   .format(obj.name))
                    self.log.error(e)
                    l1_key = ('', '', '')
                match = re.match(r'^(USN|RH.A)-.*$', obj.name)
                if match:
                    l2_key = match.group(1)
                else:
                    l2_key = ''
                index.setdefault(l1_key, {})\
                    .setdefault(l2_key, [])\
                    .append((obj.name, obj.id))
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('advisory-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_cves(self):
        self.log.info("Exporting CVEs ...")
        template = self.env.get_template('cve.html')
        _rootdir = os.path.join(self.htmldir, 'cve')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(CVE, CVEAdapter)
        index = {}
        for obj in objs:
            parts = obj.name.upper().split('-', maxsplit=2)
            if parts[0] == 'CVE':
                index.setdefault(parts[0], {})\
                    .setdefault(parts[1], {})\
                    .setdefault(parts[2][:1], [])\
                    .append((obj.name, obj.id))

            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('cve-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_cpes(self):
        self.log.info("Exporting CPEs ...")
        template = self.env.get_template('cpe.html')
        _rootdir = os.path.join(self.htmldir, 'cpe')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(CPE, CPEAdapter)
        index = []
        for obj in objs:
            index.append((obj.wfn.bind_to_fs(), obj.id))
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('cpe-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_source_projects(self):
        self.log.info("Exporting source projects ...")
        template = self.env.get_template('source-project.html')
        _rootdir = os.path.join(self.htmldir, 'source-project')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(SourceProject, SourceProjectAdapter)
        index = dict()
        for obj in objs:
            index_letter = str(obj.name)[0].upper()
            index.setdefault(index_letter, list()).append(obj)
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('source-project-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_source_packages(self):
        self.log.info("Exporting source packages ...")
        template = self.env.get_template('source-package.html')
        _rootdir = os.path.join(self.htmldir, 'source-package')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(SourcePackage, SourcePackageAdapter)
        index = dict()
        for obj in objs:
            index_letter = str(obj.name)[0].upper()
            index.setdefault(index_letter, dict())\
                .setdefault(obj.name, list())\
                .append(obj)
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('source-package-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_distribution_packages(self):
        self.log.info("Exporting distribution packages ...")
        template = self.env.get_template('distribution-package.html')
        _rootdir = os.path.join(self.htmldir, 'distribution-package')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(DistributionPackage,
                                 DistributionPackageAdapter)
        index = {}
        for obj in objs:
            index_letter = str(obj.name)[0].upper()
            index.setdefault(index_letter, []).append(obj)
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('distribution-package-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def export_product_packages(self):
        self.log.info("Exporting product packages ...")
        template = self.env.get_template('product-package.html')
        _rootdir = os.path.join(self.htmldir, 'product-package')
        os.makedirs(_rootdir, exist_ok=True)
        objs = self.db_api.query(ProductPackage, ProductPackageAdapter)
        index = dict()
        for obj in objs:
            product_name = str(obj.product)
            package_name = obj.name
            index.setdefault(product_name, {})\
                .setdefault(package_name[0].upper(), [])\
                .append(obj)
            path = os.path.join(_rootdir, '{}.html'.format(obj.id))
            with open(path, 'w') as f:
                f.write(template.render(root='..', obj=obj))

        template = self.env.get_template('product-package-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', index=index))

    def generate_reports(self):
        self.log.info("Generating reports ...")
        template = self.env.get_template('unresolved-cves.html')
        objs = self.db_api.query(ProductPackage, ProductPackageAdapter)
        data = {
            'stat': {},
            'objs': {},
        }
        for x in objs:
            related_issues = x.related_issues(merge=True)
            if len(related_issues) == 0:
                continue
            product_name = str(x.product)
            stat = data['stat'].setdefault(product_name, {})
            stat.setdefault('affected', list())
            stat.setdefault('resolved', list())
            stat.setdefault('packages', set())
            _related_issues = dict()
            for key, value in related_issues.items():
                is_tracked = value['tracked']
                issues = value['issues']
                _issues = list()
                if is_tracked:
                    for item in issues:
                        if item['issue'].affected:
                            stat['affected'].append(key)
                            if item['issue'].resolved:
                                stat['resolved'].append(key)
                            else:
                                _issues.append(item)
                else:
                    direct = False
                    for item in issues:
                        if item['direct']:
                            direct = True
                            if item['issue'].affected:
                                _issues.append(item)
                                stat['affected'].append(key)
                            break
                    if not direct:
                        for item in issues:
                            _issues.append(item)
                            stat['affected'].append(key)
                if _issues:
                    _related_issues[key] = (is_tracked, _issues)
            if _related_issues:
                stat['packages'].add(x)
                key = '{}-{}'.format(x.name, x.version)
                data['objs'].setdefault(product_name, dict())\
                    .setdefault(key, list()).append((x, _related_issues))

        _rootdir = os.path.join(self.htmldir, 'reports')
        os.makedirs(_rootdir, exist_ok=True)
        path = os.path.join(_rootdir, 'unresolved-cves.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..', data=data))

        template = self.env.get_template('reports-index.html')
        path = os.path.join(_rootdir, 'index.html')
        with open(path, 'w') as f:
            f.write(template.render(root='..'))

        _rootdir = os.path.join(self.filesdir, 'reports')
        os.makedirs(_rootdir, exist_ok=True)
        path = os.path.join(_rootdir, 'unresolved-cves.csv')
        with open(path, 'w') as csvfile:
            fieldnames = ['project', 'version', 'product', 'distribution',
                          'cve', 'cvss_v2', 'cvss_v3', 'affected', 'resolved']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()

            for product_name, product_packages in data['objs'].items():
                for package_name, package_issues in product_packages.items():
                    for product_package, related_issues in package_issues:
                        for cve_number, (tracked, issues) in \
                                related_issues.items():
                            issue = issues[0]
                            row = {
                                'project': product_package.source_package.name,
                                'version':
                                    product_package.source_package.version,
                                'product': product_name,
                                'distribution':
                                    str(product_package.product_distribution),
                                'cve': cve_number,
                            }
                            cve = issue['issue'].issue
                            cvss = cve.cvss2
                            row['cvss_v2'] = cvss.base_score if cvss else '0.0'
                            cvss = cve.cvss3
                            row['cvss_v3'] = cvss.base_score if cvss else '0.0'
                            if tracked:
                                row.update({
                                    'affected': issue['issue'].affected,
                                    'resolved': issue['issue'].resolved,
                                })
                            else:
                                if issue['direct']:
                                    row.update({
                                        'affected': issue['issue'].affected,
                                        'resolved': False,
                                    })
                                else:
                                    row.update({
                                        'affected': True,
                                        'resolved': False
                                    })
                            writer.writerow(row)


class ApplyCpeOverridesAction(Action):
    def take_action(self):
        path = self.mapped_args.get('path', None)
        config = ConfigDir(path)
        for key in config:
            data = config.get(key)
            meta = data.pop('__meta__')
            if meta['is_empty']:
                continue
            cpe_parts = dict(zip(meta['schema'], meta['key']))
            if not cpe_parts:
                continue

            cpe = CPEAdapter.new(
                part=cpe_parts.get('part'),
                vendor=cpe_parts.get('vendor'),
                product=cpe_parts.get('product'),
            )
            self.log.info("Processing CPE {}".format(str(cpe.wfn)))

            for project_data in data.get('projects', []):
                try:
                    project = SourceProjectAdapter(
                        name=project_data.get('name'),
                        type=project_data.get('type'),
                    )
                    self.log.info("- adding project {}".format(str(project)))
                    project.add_cpe(cpe)
                    project.commit()
                except: # noqa
                    self.log.warning(
                        "No project matchin '{}'".format(project_data))


class ApplyCveOverridesAction(Action):
    def take_action(self):
        path = self.mapped_args.get('path', None)
        config = ConfigDir(path)
        for elements in config:
            self._update_cves(config, elements)

    def _build_query(self, rule):
        query = None
        adapter = None

        # Build query object
        filter_by = rule.get('product')
        if filter_by:
            query = self.db_api.session.query(ProductPackage) \
                .join(DistributionPackage) \
                .join(Product) \
                .join(SourcePackage)
            adapter = ProductPackageAdapter

        filter_by = rule.get('distribution')
        if filter_by:
            if query is None:
                query = self.db_api.session \
                    .query(DistributionPackage)
                adapter = DistributionPackageAdapter

            query = query \
                .join(Distribution).join(SourcePackage)

        if query is None:
            query = self.db_api.session.query(SourcePackage)
            adapter = SourcePackageAdapter

        query = query.join(SourceProject)

        return query, adapter

    def _add_filter(self, query, rule):
        # Add filters
        filter_by = rule.get('package')
        if filter_by:
            filter_by_item = filter_by.get('name', '*')
            if filter_by_item != '*':
                query = query.filter(
                    SourceProject.name == filter_by_item)

            filter_by_item = filter_by.get('version', '*')
            if filter_by_item != '*':
                query = query.filter(
                    SourcePackage.version == filter_by_item)

        filter_by = rule.get('product')
        if filter_by:
            filter_by_item = filter_by.get('name', '*')
            if filter_by_item != '*':
                query = query.filter(
                    Product.name == filter_by_item)

            filter_by_item = filter_by.get('version', '*')
            if filter_by_item != '*':
                query = query.filter(
                    Product.version == filter_by_item)

        filter_by = rule.get('distribution')
        if filter_by:
            filter_by_item = filter_by.get('name', '*')
            if filter_by_item != '*':
                query = query.filter(
                    Distribution.name == filter_by_item)

            filter_by_item = filter_by.get('version', '*')
            if filter_by_item != '*':
                query = query.filter(
                    Distribution.version == filter_by_item)

        return query

    def _update_cve(self, package, cve_number, cve_status):
        cve = CVEAdapter.new(name=cve_number)
        affected = to_bool(
            cve_status.get('affected', 'True'))
        resolved = to_bool(
            cve_status.get('affected', 'False'))
        package.add_cve(cve,
                        affected=affected,
                        resolved=resolved)

    def _update_cves(self, config, elements):
        try:
            name, version = elements
            rules = config.get(elements).get('rules', [])
            for rule in rules:
                cves = rule.get('cve')
                if cves is None:
                    self.log.error("No cve section in '{}' rule '{}'"
                                   .format('|'.join(elements), rule))
                    continue

                rule.update({
                    'package': {
                        'name': name,
                        'version': version,
                    }
                })
                self.log.debug("Updating {} following rule {}"
                               .format('|'.join(elements), rule))
                query, adapter = self._build_query(rule)
                query = self._add_filter(query, rule)

                # Build CVE data
                cve_data = {}
                for cve_year, cve_numbers in cves.items():
                    for cve_number, cve_status in cve_numbers.items():
                        if cve_year == '*':
                            cve_name = '*'
                        else:
                            cve_name = 'CVE-{}-{}'.format(cve_year, cve_number)
                        cve_data[cve_name] = cve_status

                # Update CVEs
                cve_status = cve_data.get('*')
                if cve_status:
                    for x in query.all():
                        y = adapter(x)
                        related_issues = y.related_issues(merge=True)
                        for cve_number in related_issues:
                            self._update_cve(y, cve_number, cve_status)
                else:
                    for x in query.all():
                        y = adapter(x)
                        related_issues = y.related_issues(merge=True)
                        for cve_number in related_issues:
                            cve_status = cve_data.get(cve_number)
                            if cve_status:
                                self._update_cve(y, cve_number, cve_status)

                self.db_api.session.commit()
        except: # noqa
            self.log.exception("Something went wrong")


class UpdateSourceProjectAction(Action):
    def take_action(self):
        if 'id' in self.mapped_args:
            prj = SourceProjectAdapter(id=self.mapped_args.get('id'))
        elif 'name' in self.mapped_args:
            prj = SourceProjectAdapter(name=self.mapped_args.get('name'))
        else:
            raise Exception("Need id or name to load source project")

        if 'link_cpe' in self.mapped_args:
            wfn = CpeWFN(self.mapped_args.get('link_cpe'))
            prj.add_cpe_wfn(wfn)
            prj.commit()


class ListSourceProjectAction(Action):
    def take_action(self):
        objs = self.db_api.query(SourceProject, SourceProjectAdapter)
        if 'name' in self.mapped_args:
            name = self.mapped_args['name']
            for x in objs:
                if x.name == name:
                    yield x
        elif 'cpe' in self.mapped_args:
            wfn = CpeWFN(self.mapped_args['cpe'])
            _kwargs = dict()
            for key in ('part', 'vendor', 'product'):
                if wfn.get(key).is_string:
                    _kwargs[key] = str(wfn.get(key))
            cpes = self.db_api.query(CPE, CPEAdapter, filter_by=_kwargs)
            for cpe in cpes:
                for x in cpe.projects:
                    yield x
        else:
            for x in objs:
                yield x
