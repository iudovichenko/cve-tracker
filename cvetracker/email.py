#!/usr/bin/python

import mimetypes
import smtplib
import os

from email import encoders
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

from cvetracker.config import CONFIG


class EmailHelper(object):
    def __init__(self):
        conf = CONFIG.config
        self.host = conf.get('smtp', 'host')
        self.port = conf.get('smtp', 'port')
        self.username = conf.get('smtp', 'username', fallback=None)
        self.password = conf.get('smtp', 'password', fallback=None)
        self.smtp_ssl = conf.getboolean('smtp', 'smtp-ssl', fallback=False)

    def send(self, message):
        message.update()

        if self.smtp_ssl:
            SMTP = smtplib.SMTP_SSL
        else:
            SMTP = smtplib.SMTP

        with SMTP(self.host, self.port) as server:
            server.ehlo()
            if self.username:
                if not self.smtp_ssl:
                    server.starttls()
                    server.ehlo()
                server.login(self.username, self.password)

            server.send_message(message.msg, message.from_addr,
                                message.to_addr)
            server.quit()

    def send_message(self, from_addr, to_addr, message):
        if self.smtp_ssl:
            SMTP = smtplib.SMTP_SSL
        else:
            SMTP = smtplib.SMTP

        with SMTP(self.host, self.port) as server:
            server.ehlo()
            if self.username:
                if not self.smtp_ssl:
                    server.starttls()
                    server.ehlo()
                server.login(self.username, self.password)

            if message.get('From') is None:
                message['From'] = to_addr

            if message.get('To') is None:
                message['To'] = to_addr

            server.send_message(message, from_addr, to_addr)
            server.quit()


class EmailMessage(object):
    def __init__(self, from_name=None, from_addr=None,
                 to_name=None, to_addr=None):
        self.msg = MIMEMultipart('alternative')
        self.from_name = from_name
        self.from_addr = from_addr
        self.to_name = to_name
        self.to_addr = to_addr

    def field_from(self, address, name=None):
        self.from_addr = address
        self.from_name = name or address

    def field_to(self, address, name=None):
        self.to_addr = address
        self.to_name = name or address

    def subject(self, text):
        self.msg['Subject'] = text

    def body(self, text, message_type='plain'):
        self.msg.attach(MIMEText(text, message_type))

    def update(self):
        assert self.from_addr, "'From' address is not set"
        assert self.to_addr, "'To' address is not set"
        self.msg['From'] = self.from_name or self.from_addr
        self.msg['To'] = self.to_name or self.to_addr
        self.msg['Reply-To'] = self.to_addr

    def attach_file(self, path):
        filename = os.path.split(path)[-1]
        # Guess the content type based on the file's extension.  Encoding
        # will be ignored, although we should check for simple things like
        # gzip'd or compressed files.
        ctype, encoding = mimetypes.guess_type(path)
        if ctype is None or encoding is not None:
            # No guess could be made, or the file is encoded (compressed), so
            # use a generic bag-of-bits type.
            ctype = 'application/octet-stream'
        maintype, subtype = ctype.split('/', 1)
        if maintype == 'text':
            with open(path) as fp:
                # Note: we should handle calculating the charset
                attachment = MIMEText(fp.read(), _subtype=subtype)
        elif maintype == 'image':
            with open(path, 'rb') as fp:
                attachment = MIMEImage(fp.read(), _subtype=subtype)
        elif maintype == 'audio':
            with open(path, 'rb') as fp:
                attachment = MIMEAudio(fp.read(), _subtype=subtype)
        else:
            with open(path, 'rb') as fp:
                attachment = MIMEBase(maintype, subtype)
                attachment.set_payload(fp.read())
            # Encode the payload using Base64
            encoders.encode_base64(attachment)
        # Set the filename parameter
        attachment.add_header('Content-Disposition', 'attachment',
                              filename=filename)
        self.msg.attach(attachment)
