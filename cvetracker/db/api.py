
import datetime
import logging

from itertools import chain

from cvetracker.config import CONFIG
from cvetracker.db.models import *

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import scoped_session
from sqlalchemy.event import listen


class DBAPI(object):
    log = logging.getLogger(__name__)

    MODELS_WITH_PROPERTIES = [
        'Advisory',
        'CVE',
        'Distribution',
        'Release',
        'SourcePackage',
        'ProductDistributionPackage',
        'SourcePackageDistribution',
    ]

    @property
    def session(self):
        return CONFIG.session_registry()

    @classmethod
    def initialize(cls):
        if CONFIG.session_registry is None:
            engine = create_engine(CONFIG.config['database']['uri'])
            session_factory = sessionmaker(bind=engine)
            CONFIG.session_registry = scoped_session(session_factory)
            session = CONFIG.session_registry()
            listen(session, 'before_flush', cls.listen_before_flush)
        cls.create_all()

    @classmethod
    def create_all(cls):
        session = CONFIG.session_registry()
        engine = session.get_bind()
        Base.metadata.create_all(engine)

    @classmethod
    def drop_database(cls):
        session = CONFIG.session_registry()
        engine = session.get_bind()
        Base.metadata.drop_all(bind=engine, checkfirst=True)

    @classmethod
    def listen_before_flush(cls, session, *args, **kwargs):
        for obj in chain(session.new, session.dirty):
            try:
                obj.date_modified = datetime.datetime.now()
            except: # noqa
                pass

    def get(self, cls, **kwargs):
        query = self.session.query(cls).filter_by(**kwargs)
        return query.all()

    def create(self, cls, **kwargs):
        obj = cls(**kwargs)
        self.session.add(obj)
        return obj

    def get_create(self, cls, **kwargs):
        query = self.session.query(cls).filter_by(**kwargs)
        result = query.all()
        if len(result) == 0:
            result.append(self.create(cls, **kwargs))
        return result

    def find(self,  *args, **kwargs):
        _args = list(args)
        cls = _args.pop(0)
        alias = kwargs.pop('alias', None)
        cls_name = cls.__class__.__name__
        if alias:
            if cls_name in self.MODELS_WITH_PROPERTIES:
                cls = eval(cls_name + 'Property')
            elif cls_name.endswith('Property'):
                cls = self
            else:
                raise Exception("Can't use alias with class '{}'"
                                .format(cls_name))

            res = CONFIG.session.query(cls).filter(cls.name == alias).all()
            return [x.parent for x in res]

        query = CONFIG.session.query(self)
        for name, value in kwargs.items():
            query = query.filter(getattr(self, name) == value)

        return query.all()

    def add_property(self, obj, name, value, unique=False):
        cls_name = type(obj).__name__
        # cls_name = obj.__class__.__name__
        self.log.debug(dir(obj))
        property_cls = eval(cls_name + 'Property')

        if unique:
            prop = self.get_create(property_cls, parent_id=obj.id,
                                   name=name)
            if isinstance(prop, list):
                raise Exception("Multiple properties found but not allowed.")
            prop.value = value
        else:
            prop = self.get_create(property_cls, parent_id=obj.id,
                                   name=name, value=value)

        obj.properties.add(prop)

    def query(self, *args, **kwargs):
        _args = {'adapter': None}
        _args.update(dict(zip(('cls', 'adapter'), args)))

        cls = _args['cls']
        cls_adapter = _args['adapter']

        join = kwargs.pop('join', [])
        filter_by = kwargs.pop('filter_by', {})
        filter_by.update(kwargs)

        query = self.session.query(cls)
        for obj in set([x for x, _ in join]):
            query = query.join(obj)
        for name, value in filter_by.items():
            query = query.filter(getattr(cls, name) == value)
        for obj, filter in join:
            for name, value in filter.items():
                query = query.filter(getattr(obj, name) == value)

        if cls_adapter:
            for obj in query.all():
                yield cls_adapter(obj)
        else:
            for obj in query.all():
                yield obj
