
import datetime
import logging
import threading

from contextlib import contextmanager
from itertools import chain

from cvetracker.db.models import *

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.event import listen


def listen_after_flush(session, *args, **kwargs):
    for obj in chain(session.new, session.dirty):
        if session.is_modified(obj):
            try:
                obj.date_modified = datetime.datetime.now()
            except: # noqa
                pass


class DBAPI(threading.local):
    log = logging.getLogger(__name__)

    def __init__(self, db_uri):
        self._session = None
        self._read_only = False
        self._engine = create_engine(db_uri)
        self._session_factory = sessionmaker(bind=self._engine)

    @property
    def session(self):
        return self._session

    @contextmanager
    def get_session(self):
        if self._session is None:
            self._session = self._session_factory()
            listen(self._session, 'after_flush', listen_after_flush)

            try:
                yield self._session
                self._session.commit()
            except Exception as e:
                self.log.exception(e)
                self._session.rollback()
            finally:
                self._session.close()
                self._session = None
        else:
            yield self._session

    def create_database(self):
        Base.metadata.create_all(self._engine)

    def drop_database(self):
        Base.metadata.drop_all(bind=self._engine, checkfirst=True)

    def get(self, model, **kwargs):
        query = self.session.query(model).filter_by(**kwargs)
        return query.all()

    def create(self, model, **kwargs):
        obj = model(**kwargs)
        self.session.add(obj)
        return obj

    def get_create(self, cls, **kwargs):
        query = self.session.query(cls).filter_by(**kwargs)
        result = query.all()
        if len(result) == 0:
            result.append(self.create(cls, **kwargs))
        return result

    def query(self, *args, **kwargs):
        _args = {'adapter': None}
        _args.update(dict(zip(('cls', 'adapter'), args)))

        cls = _args['cls']
        cls_adapter = _args['adapter']

        join = kwargs.pop('join', [])
        filter_by = kwargs.pop('filter_by', {})
        filter_by.update(kwargs)

        query = self.session.query(cls)
        for obj in set([x for x, _ in join]):
            query = query.join(obj)
        for name, value in filter_by.items():
            query = query.filter(getattr(cls, name) == value)
        for obj, filter in join:
            for name, value in filter.items():
                query = query.filter(getattr(obj, name) == value)

        if cls_adapter:
            for obj in query.all():
                yield cls_adapter(obj)
        else:
            for obj in query.all():
                yield obj
