
import datetime
import logging
import json
import os
import re
import time
import urllib3
import textwrap

from cvss import CVSS2, CVSS3

from cvetracker.cpe import CpeWFN

from cvetracker.db.models import * # noqa
from cvetracker.misc import DebianVersion
from cvetracker.formatter import SafeFormatter

from cvetracker.appdata import APPDATA
from sqlalchemy import func
from sqlalchemy.orm.exc import NoResultFound

from configdir import ConfigDir


class RelatedIssueAdapter(object):
    def __init__(self, issue, package=None):
        self._issue = issue
        self._package = package

    def __getattr__(self, item):
        return self.__dict__.get(item, getattr(self._issue, item))

    @property
    def id(self):
        return None

    @property
    def model_name(self):
        return 'RelatedIssue'

    @property
    def package(self):
        return self._package

    def dict(self):
        data = {
            '__model__': self.model_name,
            'id': self.id,
            'origin_issue': self._issue.dict(),
            'package': self.package.dict(),
        }
        return self._issue.dict(append=data)


# class Catalog(object):
#     _catalog = {}
#
#     def __new__(cls, instance=None, *args, **kwargs):
#         if instance:
#             return cls._catalog.setdefault(instance, super().__new__(cls))
#         return cls.load(*args, **kwargs)


# class GenericAdapter(Catalog):
#     db_api = DBAPI()
#     log = logging.getLogger(__name__)
#     changes = list()
#
#     def __init__(self, instance=None, *args, **kwargs):
#         self.__dict__.setdefault('_', None)
#         if instance is None:
#             if self._ is None:
#                 raise Exception("Can't initialiase object '{}'".format(self))
#         else:
#             if self.__dict__['_'] is None:
#                 self._ = instance
#                 self.db_api.session.add(self._)
#                 self.db_api.session.flush()

class GenericAdapter(object):
    log = logging.getLogger(__name__)
    changes = list()

    def __init__(self, instance):
        self._ = instance

    def __getattr__(self, item):
        return getattr(self._, item)

    @property
    def db_api(self):
        return APPDATA.db_api

    @classmethod
    def load(cls, **kwargs):
        model_name = re.sub(r'Adapter$', '', cls.__name__)
        cls.log.debug(kwargs)

        alias = kwargs.pop('alias', None)
        if alias:
            objs = list(cls.find_by_property('alias', value=alias))
            if len(objs) > 0:
                if len(objs) > 1:
                    cls.log.error("Multiple objects found for alias '{}'"
                                  .format(alias))
                return objs[0]

        session = APPDATA.db_api.session
        model = eval(model_name)
        query = session.query(model)
        for key, value in kwargs.items():
            if isinstance(value, str):
                query = query.filter(
                    func.lower(getattr(model, key)) == value.lower())
            else:
                query = query.filter(getattr(model, key) == value)
        instance = query.one()
        return cls(instance)

    @classmethod
    def new(cls, **kwargs):
        try:
            return cls.load(**kwargs)
        except NoResultFound:
            session = APPDATA.db_api.session
            model = eval(re.sub(r'Adapter$', '', cls.__name__))
            kwargs.pop('alias', None)
            obj = model(**kwargs)
            session.add(obj)
            return cls(obj)

    @classmethod
    def find_by_property(cls, name, **kwargs):
        session = APPDATA.db_api.session
        model_name = re.sub(r'Adapter$', '', cls.__name__)
        model_property = eval(model_name + 'Property')
        query = session.query(model_property.parent_id)
        query = query.filter(model_property.name == name)
        if 'value' in kwargs:
            query = query.filter(
                func.lower(model_property.value) == kwargs['value'].lower())
        query = query.distinct(model_property.parent_id)
        for result in query.all():
            yield cls.load(id=result[0])

    @classmethod
    def flush_changes(cls, filename=None):
        if filename is None:
            return
        with open(filename, 'a') as f:
            while len(cls.changes):
                try:
                    f.write(json.dumps(cls.changes.pop(0)))
                    f.write('\n')
                except:
                    cls.log.exception("Can't export some changes items")

    @property
    def class_name(self):
        return self.__class__.__name__

    @property
    def model_name(self):
        return self._.__class__.__name__

    def get(self, name, default=None):
        return getattr(self, name, getattr(self._, name, default))

    def set(self, name, value):
        if getattr(self._, name, None) != value:
            self.changes.append({
                'item': self.dict(),
                'attr': name,
                'value': value,
            })
            setattr(self._, name, value)

    def search(self, *args, **kwargs):
        model = eval(re.sub(r'Adapter$', '', self.__class__.__name__))
        query = self.db_api.session.query(model)
        for name, value in kwargs.items():
            query = query.filter(getattr(model, name) == value)
        return query.all()

    def get_property(self, name, as_scalar=False, **kwargs):
        cls = eval(self._.__class__.__name__ + 'Property')
        result = self.db_api.get(cls, name=name, parent_id=self._.id)
        if len(result) == 0:
            if 'default' in kwargs:
                return kwargs['default']
            else:
                raise NoResultFound()

        if as_scalar:
            if len(result) > 1:
                raise Exception("Multiple properties found but not allowed.")
            return result[0]

        return result

    def set_property(self, name, value):
        try:
            property = self.get_property(name, as_scalar=True)
            property.value = value
        except NoResultFound:
            cls = eval(self._.__class__.__name__ + 'Property')
            property = self.db_api.create(cls, name=name, value=value,
                                          parent_id=self._.id)
        self._.properties.add(property)

    def add_property(self, name, value):
        cls = eval(self._.__class__.__name__ + 'Property')
        result = self.db_api.get(cls, name=name, value=value,
                                 parent_id=self._.id)
        if len(result) == 0:
            property = self.db_api.create(cls, name=name, value=value,
                                          parent_id=self._.id)
            self._.properties.add(property)

    def properties(self, name=None):
        for x in self._.properties:
            if name is None:
                yield x.name, x.value
            elif x.name.lower() == str(name).lower():
                yield x.name, x.value

    # def commit(self):
    #     self.db_api.session.commit()

    def __repr__(self):
        return '{0.model_name}(ID:{0.id})'.format(self)

    def export(self):
        return self.dict()

    def dict(self, **kwargs):
        data = kwargs.get('data', {})
        append = kwargs.get('append', {})
        p = {}

        try:
            for name, value in self.properties():
                p.setdefault(name, []).append(value)
        except: # noqa
            pass

        for k, v in p.items():
            if len(v) == 1:
                p[k] = v[0]

        data.update({
            '__model__': self._.__class__.__name__,
            # '__str__': str(self),
            'id': self.id,
        })
        data.update(append)
        data.update({
            'property': p
        })
        return data

    def show(self, **kwargs):
        cols = []
        data = []
        raw = self.export()

        sf = SafeFormatter()
        if kwargs.get('formatter', None) == 'TableFormatter':
            for name, fmt in kwargs.get('fields', ()):
                value = sf.format(fmt, **raw)
                cols.append(name)
                data.append('\n'.join(textwrap.wrap(value)))

            for key, value in raw.get('property', {}).items():
                if isinstance(value, list):
                    for x in value:
                        cols.append('Property:{}'.format(key))
                        data.append(x)
                else:
                    cols.append('Property:{}'.format(key))
                    data.append(value)
        else:
            for k, v in raw.items():
                cols.append(k)
                data.append(v)

        return cols, data, raw


class AdvisoryAdapter(GenericAdapter):
    @property
    def cves(self):
        for x in self._.cves:
            yield CVEAdapter(x)

    @property
    def source_packages(self):
        for x in self._.source_packages:
            yield SourcePackageAdapter(x)

    @property
    def distribution_packages(self):
        for x in self._.distribution_packages:
            yield DistributionPackageAdapter(x)

    @property
    def product_packages(self):
        for x in self._.product_packages:
            yield ProductPackageAdapter(x)

    def add_cve(self, cve):
        self._.cves.add(cve._)

    def add_source_package(self, package):
        self._.source_packages.add(package._)

    def add_package(self, package):
        self._.distribution_packages.add(package._)

    # def commit(self):
    #     super().commit()

    def update(self, data={}):
        url = data.get('url')
        if url:
            self.set('url', url)

        subject = data.get('subject')
        if subject:
            self.set('subject', subject)

        ts = data.get('timestamp')
        if ts:
            self.set_property(name='released_on', value=str(ts))

        for cve_name, cve_data in data.get('cves', {}).items():
            cve = CVEAdapter.new(name=cve_name)
            cve.update(cve_data)
            self._.cves.add(cve._)

        overrides_path = APPDATA.config.get('common', 'overrides')
        overrides = ConfigDir(os.path.join(overrides_path, 'packages'))
        re_sep = re.compile(r'[\\\/]')
        for pkg_data in data.get('packages', []):
            name = re_sep.sub('|', pkg_data['name'])
            prj_data = overrides.match(name)
            prj_data.setdefault('name', name.split('|')[-1])
            prj_data.setdefault('type', None)
            self.log.debug("{} --> {}".format(name, prj_data))

            prj, pkg = SourceProjectAdapter.new_source_package(
                project_name=prj_data['name'],
                project_alias=prj_data['name'],
                project_type=prj_data['type'],
                package_version=pkg_data['upstream_version']
            )
            prj.update(prj_data)
            prj.refresh()

            self._.source_packages.add(pkg._)

            dist = DistributionAdapter.load_by_alias(alias=pkg_data['dist'])

            dist_pkg = DistributionPackageAdapter.new(
                source_package=pkg._,
                distribution=dist._,
                version=pkg_data['full_version']
            )

            self._.distribution_packages.add(dist_pkg._)

        # self.commit()

    def show(self, formatter=None):
        fields = (
            ('ID', '{id}'),
            ('Name', '{name}'),
            ('Subject', '{subject}'),
            ('URL', '{url}'),
        )
        cols, data, raw = super().show(fields=fields, formatter=formatter)

        if formatter == 'TableFormatter':
            fmt = '{0[project][name]}'
            for x in raw.get('source_packages', []):
                cols.append('Package')
                data.append(fmt.format(x))

            fmt = '{0[source_package][project][name]}-' \
                  '{0[source_package][version]} ' \
                  '({0[distribution][name]} ' \
                  '{0[distribution][version]} ' \
                  '{0[distribution][arch]})'
            for x in raw.get('distribution_packages', []):
                cols.append('Distribution package')
                data.append(fmt.format(x))

            fmt = '{0[name]}'
            for x in raw.get('cves', []):
                cols.append('CVE')
                data.append(fmt.format(x))

        return cols, data, raw

    def export(self):
        data = super().export()

        data['source_packages'] = [
            x.dict() for x in self.source_packages
        ]

        data['distribution_packages'] = [
            x.dict() for x in self.distribution_packages
        ]

        data['cves'] = [
            x.dict() for x in self.cves
        ]

        return data

    def dict(self, append={}):
        data = {
            'name': self.name,
            'subject': self.subject,
            'url': self.url,
        }
        super().dict(data=data, append=append)
        return data


class CPEAdapter(GenericAdapter):
    def __str__(self):
        return self.wfn.bind_to_fs()

    def __repr__(self):
        return str(self.wfn)

    @property
    def projects(self):
        for x in self._.projects:
            yield SourceProjectAdapter(x)

    @property
    def cves(self):
        for x in self._.cves:
            yield CVEAdapter(x)

    def show(self, formatter=None):
        fields = (
            ('ID', '{id}'),
            ('Part', '{part}'),
            ('Vendor', '{vendor}'),
            ('Product', '{product}'),
        )
        cols, data, raw = super().show(fields=fields, formatter=formatter)

        return cols, data, raw

    def export(self):
        data = super().export()

        return data

    def dict(self, append={}):
        data = {
            'part': self.part,
            'vendor': self.vendor,
            'product': self.product,
        }
        super().dict(data=data, append=append)
        return data

    @property
    def wfn(self):
        wfn = CpeWFN()
        wfn.set('part', self.part)
        wfn.set('vendor', self.vendor)
        wfn.set('product', self.product)
        return wfn


class CVEAdapter(GenericAdapter):
    def __str__(self):
        return self.name

    def __repr__(self):
        return '{0.model_name}(ID:{0.id}, Name:{0.name})'.format(self)

    @classmethod
    def from_nvd(cls, data):
        name = data['cve']['CVE_data_meta']['ID']
        cve = CVEAdapter.new(name=name)
        cve.set('nvd_json', data)

        for x in data['cve']['references']['reference_data']:
            cve.add_reference(x['url'])

        for x in data['cve']['description']['description_data']:
            if x['lang'] == 'en':
                cve.set('subject', x['value'])

        impact = data.get('impact', {})

        cve.set('cvss_v2', impact.get('baseMetricV2', {})
                .get('cvssV2', {}).get('vectorString'))

        cve.set('cvss_v3', impact.get('baseMetricV3', {})
                .get('cvssV3', {}).get('vectorString'))

        return cve

    @property
    def advisories(self):
        for x in self._.advisories:
            yield AdvisoryAdapter(x)

    @property
    def cpes(self):
        for x in self._.cpes:
            yield CPEAdapter(x)

    @property
    def source_package_issues(self):
        for x in self._.source_packages:
            yield SourcePackageIssueAdapter(x)

    @property
    def source_packages(self):
        for x in self.source_package_issues:
            yield x.package

    @property
    def urls(self):
        for _, value in self.properties(name='url'):
            yield value

    @property
    def distribution_packages(self):
        for x in self.distribution_package_issues:
            yield x.package

    @property
    def distribution_package_issues(self):
        for x in self._.distribution_packages:
            yield DistributionPackageIssueAdapter(x)

    @property
    def product_package_issues(self):
        for x in self._.product_packages:
            yield ProductPackageIssueAdapter(x)

    @property
    def product_packages(self):
        for x in self._.product_packages:
            yield ProductPackageAdapter(x.package)

    @property
    def cvss2(self):
        vector = self.get('cvss_v2', None)
        if vector:
            m = re.match(r'\((.*)\)', vector)
            if m:
                return CVSS2(m.group(1))
        return None

    @property
    def cvss3(self):
        vector = self.get('cvss_v3', None)
        if vector:
            if vector.startswith('CVSS:3.0'):
                cvss3 = CVSS3(vector)
            else:
                cvss3 = CVSS3('CVSS:3.0/{}'.format(vector))
            return cvss3
        return None

    def add_cpe(self, cpe):
        self._.cpes.add(cpe._)

    def add_reference(self, value):
        self.add_property('reference', value=value)

    def show(self, formatter=None):
        fields = (
            ('ID', '{id}'),
            ('Name', '{name}'),
            ('Subject', '{subject}'),
        )
        cols, data, raw = super().show(fields=fields, formatter=formatter)

        if formatter == 'TableFormatter':
            for x in raw.get('advisories', []):
                cols.append('Advisory')
                data.append(x['name'])

            for x in raw.get('source_package_issues', []):
                cols.append('Affects')
                data.append('{__str__} <{id}>'.format(**x))

            for x in raw.get('distribution_package_issues'):
                cols.append('Affected Distribution')
                data.append('{__str__} <{id}>'.format(**x))

            for x in raw.get('product_package_issues'):
                cols.append('Affected Product')
                data.append('{__str__} <{id}>'.format(**x))

            cvss = self.cvss2
            if cvss:
                cols.append('CVSS V2 Base Score')
                data.append(cvss.base_score)
                cols.append('CVSS V2 Vector')
                data.append(cvss.vector)

            cvss = self.cvss3
            if cvss:
                cols.append('CVSS V3 Base Score')
                data.append(cvss.base_score)
                cols.append('CVSS V3 Vector')
                data.append(cvss.vector)

        return cols, data, raw

    def export(self):
        data = super().export()

        data['advisories'] = [
            x.dict() for x in self.advisories
        ]

        data['source_package_issues'] = [
            x.dict() for x in self.source_package_issues
        ]

        data['distribution_package_issues'] = [
            x.dict() for x in self.distribution_package_issues
        ]

        data['product_package_issues'] = [
            x.dict() for x in self.product_package_issues
        ]

        return data

    def related_issues(self):
        related_issues = {
            'source_packages': [],
            'distribution_packages': [],
            'product_packages': [],
        }

        for x in self.product_packages:
            y = x.related_issues(merge=True).get(self.name)
            if y:
                related_issues['product_packages'].append(y)

        for x in self.distribution_packages:
            y = x.related_issues(merge=True).get(self.name)
            if y:
                related_issues['distribution_packages'].append(y)

        for x in self.source_packages:
            y = x.related_issues(merge=True).get(self.name)
            if y:
                related_issues['source_packages'].append(y)

        return related_issues

    def update(self, data={}):
        subject = data.get('subject')
        if subject is not None:
            self.set('subject', subject)

        url = data.get('url')
        if url is not None:
            self.add_property(name='URL', value=url)

        for url in data.get('references', []):
            self.add_property(name='reference', value=url)

    def update_status(self):
        for sp in self.source_packages:
            for dp in sp.distribution_packages:
                issues = list(dp.issues(self))
                if len(issues) == 0:
                    dp.add_cve(self)
                for pp in dp.product_packages:
                    issues = list(pp.issues(self))
                    if len(issues) == 0:
                        pp.add_cve(self)
        # self.commit()

    def dict(self, append={}):
        data = {
            'name': self.name,
            'subject': self.subject,
        }
        super().dict(data=data, append=append)
        return data


class DistributionAdapter(GenericAdapter):
    def __str__(self):
        if self.name is None:
            return '_NONE_'

        fmt = []
        fmt.append('{0.name}')
        if self.version:
            fmt.append('{0.version}')
        if self.arch:
            fmt.append('({0.arch})')
        return ' '.join(fmt).format(self)

    def __repr__(self):
        return '{0.model_name}(ID:{0.id}, Name:{0.name},' \
               ' Version:{0.version}, Arch:{0.arch})'.format(self)

    @property
    def source_packages(self):
        for x in self._.packages:
            yield SourcePackageAdapter(x.source_package), x.version

    @property
    def distribution_packages(self):
        for x in self._.packages:
            yield DistributionPackageAdapter(x)

    @property
    def products(self):
        products = set()
        for x in self.product_packages():
            products.add(x.product)
        return products

    def product_packages(self, product=None):
        for x in self._.product_packages:
            if product is None:
                yield ProductPackageAdapter(x)
            elif x.product.id == product.id:
                yield ProductPackageAdapter(x)

    def add_package(self, source_package, version=None):
        obj = DistributionPackageAdapter.new(
            source_package=source_package._,
            distribution=self._,
            version=version,
        )
        return obj

    @classmethod
    def load_by_alias(cls, alias=None):
        if alias is None:
            return DistributionAdapter.none()

        aliases = list(cls.find_by_property('alias', value=alias))
        if len(aliases) == 0:
            if '-' in alias:
                alias_ = alias.rsplit('-', 1)[0]
                cls.log.debug("WARNING: No distribution found for alias '{}',"
                              " trying '{}'".format(alias, alias_))
                return cls.load_by_alias(alias_)
            else:
                cls.log.debug("ERROR: No distribution found for alias '{}'"
                              .format(alias))
                return DistributionAdapter.none()

        if len(aliases) > 1:
            raise Exception("Multiple distributions found with alias {}"
                            .format(alias))

        return aliases[0]

    @classmethod
    def none(cls):
        return cls.new(name=None, version=None, arch=None)

    @property
    def is_none(self):
        return self.name is None

    def show(self, formatter=None):
        fields = (
            ('ID', '{id}'),
            ('Name', '{name}'),
            ('Version', '{version}'),
            ('Architecture', '{arch}'),
        )
        cols, data, raw = super().show(fields=fields, formatter=formatter)

        if formatter == 'TableFormatter':
            for x in raw.get('distribution_packages'):
                cols.append('Distribution package')
                data.append('{__str__} <{id}>'.format(**x))

        return cols, data, raw

    def export(self):
        data = super().export()

        data['distribution_packages'] = [
            x.dict() for x in self.distribution_packages
        ]

        return data

    def dict(self, append={}):
        data = {
            'name': self.name,
            'version': self.version,
            'arch': self.arch,
        }
        super().dict(data=data, append=append)
        return data


class DistributionPackageAdapter(GenericAdapter):
    def __str__(self):
        if self.distribution.is_none:
            fmt = '{0.name} {0.version}'
        else:
            fmt = '{0.name} {0.version} ({0.distribution!s})'
        return fmt.format(self)

    def __repr__(self):
        return '{0.model_name}(ID:{0.id}, Name:{0.name}, ' \
               'Version:{0.version}, Distribution: {0.distribution!s})'\
            .format(self)

    @property
    def advisories(self):
        for x in self._.advisories:
            yield AdvisoryAdapter(x)

    @property
    def name(self):
        return self._.source_package.project.name

    @property
    def version(self):
        return self._.version or '<empty>'

    @property
    def distribution(self):
        return DistributionAdapter(self._.distribution)

    @property
    def products(self):
        for x in self._.products:
            yield ProductAdapter(x.product)

    @property
    def product_packages(self):
        for x in self._.product_packages:
            yield ProductPackageAdapter(x)

    @property
    def source_package(self):
        return SourcePackageAdapter(self._.source_package)

    @property
    def packages(self):
        sp = self.source_package
        for pp in self.product_packages:
            yield sp, self, pp
        else:
            if pp is None:
                yield sp, self, pp

    @property
    def cves(self):
        for x in self._.issues:
            yield DistributionPackageIssueAdapter(x)

    def issues(self, cve=None):
        filter_by = {'package': self._}
        if cve:
            filter_by['issue'] = cve._
        for x in self.db_api.query(DistributionPackageIssue,
                                   DistributionPackageIssueAdapter,
                                   filter_by=filter_by):
            yield x

    def add_cve(self, cve, **kwargs):
        self.log.info("Adding CVE {} to distribution package {} "
                      "with args '{}'".format(str(cve), str(self), kwargs))

        obj = DistributionPackageIssueAdapter.new(package=self._, issue=cve._)
        for attr in ('affected', 'resolved'):
            if attr in kwargs:
                obj.set(attr, kwargs[attr])

        return obj

    def related_issues(self, from_parent=True, from_children=True,
                       exclude=None, merge=False):
        tracked = dict()
        related = dict()
        if exclude is None:
            exclude = list()

        for x in self.issues():
            tracked[x.issue.name] = {'issue': x, 'direct': False}

        if from_children:
            for x in self.product_packages:
                if x in exclude:
                    continue
                _tracked, _related = x.related_issues(
                    from_parent=False, from_children=True)

                for key, value in _tracked.items():
                    if key in tracked:
                        continue
                    related.setdefault(key, list()).append(value)

                for key, value in _related.items():
                    if key in tracked:
                        continue
                    related.setdefault(key, list()).extend(value)

        if from_parent:
            _tracked, _related = self.source_package.related_issues(
                from_parent=True, from_children=True, exclude=(self, )
            )

            for key, value in _tracked.items():
                if key in tracked:
                    continue
                value['direct'] = True
                related.setdefault(key, list()).append(value)

            for key, value in _related.items():
                if key in tracked:
                    continue
                related.setdefault(key, list()).extend(value)

        if merge:
            merged = dict()
            for key, value in tracked.items():
                merged[key] = {'tracked': True, 'issues': (value,)}
            for key, value in related.items():
                merged[key] = {'tracked': False, 'issues': value}
            return merged

        return tracked, related

    def show(self, formatter):
        fields = (
            ('ID', '{id}'),
            ('Name', '{source_package[project][name]}'),
            ('Version', '{version}'),
            ('Source Package',
             '{source_package[__str__]} <{source_package[id]}>'),
            ('Distribution', '{distribution[__str__]}')
        )
        cols, data, raw = super().show(fields=fields, formatter=formatter)

        if formatter == 'TableFormatter':
            for x in raw.get('advisories', []):
                cols.append('Advisory')
                data.append(x)

            for x in raw.get('cves', []):
                cols.append('CVE')
                data.append('{__str__} <{id}>'.format(**x))

            for x in raw.get('product_packages', []):
                cols.append('Product Package')
                data.append('{__str__} <{id}>'.format(**x))

            tracked, related = self.related_issues()
            for x in sorted(tracked):
                cols.append('Issue (tracked)')
                data.append(str(tracked[x]['issue']))

            for x in sorted(related):
                for y in related[x]:
                    cols.append('Issue (related)')
                    data.append('{} from {}'
                                .format(x, str(y['issue'].package)))

        return cols, data, raw

    def export(self):
        data = super().export()

        data['advisories'] = [x.dict() for x in self.advisories]
        data['cves'] = [x.dict() for x in self.cves]
        data['product_packages'] = [x.dict() for x in self.product_packages]

        return data

    def dict(self, append={}):
        data = {
            'distribution': self.distribution.dict(),
            'source_package': self.source_package.dict(),
            'name': self.name,
            'version': self.version,
        }
        super().dict(data=data, append=append)
        return data

    def update(self, **kwargs):
        if 'distribution' in kwargs:
            dist = DistributionAdapter.new(id=kwargs['distribution'])
            self._.distribution = dist._

        if 'version' in kwargs:
            self.set('version', kwargs['version'])

        # self.commit()


class DistributionPackageIssueAdapter(GenericAdapter):
    def __str__(self):
        return '{0.issue} {0.package!s} ' \
               'Affected:{0.affected} Resolved:{0.resolved}'.format(self)

    def __repr__(self):
        return '{0.model_name}(ID:{0.id}, Issue:{0.issue!s},' \
               ' Package:{0.package!s})'.format(self)

    @property
    def package(self):
        return DistributionPackageAdapter(self._.package)

    @property
    def distribution(self):
        return DistributionAdapter(self._.package.distribution)

    @property
    def affected(self):
        return self._.affected

    @affected.setter
    def affected(self, value):
        issue = CVEAdapter(self._.issue)
        self._.affected = value
        for x in self.package.product_packages:
            for y in x.issues(cve=issue):
                y.affected = value

    @property
    def issue(self):
        return CVEAdapter(self._.issue)

    @property
    def status(self):
        return self._.status or '<empty>'

    @status.setter
    def status(self, value):
        self._.status = value

    def dict(self, append={}):
        issue = CVEAdapter(self._.issue)
        data = {
            'issue': issue.dict(),
            'package': self.package.dict(),
            'affected': self.affected,
            'resolved': self.resolved,
            'status': self.status,
            'date_modified': str(self.date_modified),
        }
        super().dict(data=data, append=append)
        return data


class ProductAdapter(GenericAdapter):
    def __str__(self):
        return '{0.name} {0.version}'.format(self)

    def __repr__(self):
        return '{0.model_name}(ID:{0.id}, Name:{0.name},' \
               ' Version:{0.version})'.format(self)

    @property
    def packages(self):
        for x in self._.packages:
            yield ProductPackageAdapter(x)

    @property
    def product_packages(self):
        for x in self._.packages:
            yield ProductPackageAdapter(x)

    def show(self, formatter=None):
        fields = (
            ('ID', '{id}'),
            ('Name', '{name}'),
            ('Version', '{version}'),
        )
        cols, data, raw = super().show(fields=fields, formatter=formatter)

        if formatter == 'TableFormatter':
            for key, value in raw.get('packages', {}).items():
                cols.append('Distrirution')
                data.append('{}, {} packages'
                            .format(key, len(value)))

        return cols, data, raw

    def export(self):
        data = super().export()

        data['packages'] = {}

        for x in self.packages:
            data['packages'].setdefault(str(x.distribution), [])\
                .append(x.dict())

        return data

    def dict(self, append={}):
        data = {
            'name': self.name,
            'version': self.version,
            'vendor': self.vendor,
        }
        super().dict(data=data, append=append)
        return data


class ProductBinaryPackageAdapter(GenericAdapter):
    @property
    def product_package(self):
        return ProductPackageAdapter(self._.product_package)

    def dict(self, append={}):
        data = {
            'name': self._.name,
            'product_package': self.product_package.dict(),
        }
        super().dict(data=data, append=append)
        return data


class ProductPackageAdapter(GenericAdapter):
    def __str__(self):
        return '{0.name} {0.version} {0.product!s}'.format(self)

    def __repr__(self):
        return '{0.model_name}(ID:{0.id}, Name:{0.name},' \
               ' Version:{0.version})'.format(self)

    @property
    def name(self):
        return self._.distribution_package.source_package.project.name

    @property
    def version(self):
        return self._.version

    @version.setter
    def version(self, value):
        self.set('version', value)

    @property
    def distribution_version(self):
        return self._.distribution_package.version

    @property
    def distribution_package(self):
        return DistributionPackageAdapter(self._.distribution_package)

    @distribution_package.setter
    def distribution_package(self, value):
        self.set('distribution_package', value._)

    @property
    def upstream_version(self):
        return self._.distribution_package.source_package.version

    @property
    def distribution(self):
        return DistributionAdapter(self._.distribution_package.distribution)

    @property
    def product_distribution(self):
        return DistributionAdapter(self._.distribution)

    @product_distribution.setter
    def product_distribution(self, value):
        self.set('distribution', value._)

    @property
    def product(self):
        return ProductAdapter(self._.product)

    @product.setter
    def product(self, value):
        self.set('product', value._)

    @property
    def source_package(self):
        return SourcePackageAdapter(self._.distribution_package.source_package)

    @property
    def binary_packages(self):
        for x in self._.binary_packages:
            yield ProductBinaryPackageAdapter(x)

    def issues(self, cve=None):
        filter_by = {'package': self._}
        if cve:
            filter_by['issue'] = cve._
        for x in self.db_api.query(ProductPackageIssue,
                                   ProductPackageIssueAdapter,
                                   filter_by=filter_by):
            yield x

    def add_cve(self, cve, **kwargs):
        self.log.info("Adding CVE {} to product package {},"
                      " with args '{}'".format(str(cve), str(self), kwargs))

        obj = ProductPackageIssueAdapter.new(package=self._, issue=cve._)
        for attr in ('affected', 'resolved'):
            if attr in kwargs:
                obj.set(attr, kwargs[attr])

        return obj

    def related_issues(self, from_parent=True, from_children=True,
                       exclude=None, merge=False):
        tracked = dict()
        related = dict()

        for x in self.issues():
            tracked[x.issue.name] = {'issue': x, 'direct': False}

        if from_parent:
            _tracked, _related = self.distribution_package.related_issues(
                from_parent=True, from_children=True, exclude=(self, )
            )

            for key, value in _tracked.items():
                if key in tracked:
                    continue
                related.setdefault(key, list()).append(value)

            for key, value in _related.items():
                if key in tracked:
                    continue
                related.setdefault(key, list()).extend(value)

        if merge:
            merged = dict()
            for key, value in tracked.items():
                merged[key] = {'tracked': True, 'issues': (value,)}
            for key, value in related.items():
                merged[key] = {'tracked': False, 'issues': value}
            return merged

        return tracked, related

    def add_binary_package(self, name):
        obj = ProductBinaryPackageAdapter.new(
            product_package=self._, name=name)
        return obj

    @classmethod
    def update(cls, data={}):
        """
        :param data:
        :return:

        data = {
            "id": "",
            "source_package": "",
            "source_package_id": "",
            "spec_project": "",
            "source_project": "",
            "upstream_version": "",
            "package_origin": "",
            "distribution": {
                "alias": "",
                "name": "",
                "version": "",
                "arch": "",
            },
            "distribution_id": "",
            "product": {
                "name": "",
                "version": "",
            },
            "version": {
                "full_version": "",
            },
            "cves": [],
            "binary_packages": [],
        }
        """

        # overrides_path = APPDATA.config.get('common', 'overrides')
        overrides_path = os.path.join(APPDATA.config_dir, 'overrides')
        overrides = ConfigDir(os.path.join(overrides_path, 'projects'))
        re_sep = re.compile(r'[\\\/]')
        if 'source_package_id' in data:
            src_pkg = SourcePackageAdapter.new(
                id=data['source_package_id'])
        elif 'source_package' in data:
            name = re_sep.sub('|', data['source_project'])
            prj_data = overrides.match(name)
            prj_data.setdefault('name', name.split('|')[-1])
            prj_data.setdefault('type', None)
            cls.log.debug("{} --> {}".format(name, prj_data))

            prj, src_pkg = SourceProjectAdapter.new_source_package(
                project_name=prj_data['name'],
                project_alias=prj_data['name'],
                project_type=prj_data['type'],
                package_version=data.get('upstream_version'),
            )
            prj.update(prj_data)
            prj.refresh()

            # prj.commit()
        else:
            src_pkg = None

        version = DebianVersion(data['version']['full_version'])
        if 'distribution_package_id' in data:
            dist_pkg = DistributionPackageAdapter.new(
                id=data['distribution_package_id'])
            src_pkg = dist_pkg.source_package
        else:
            if 'distribution_id' in data:
                dist = DistributionAdapter.new(
                    id=data['distribution_id'])
            elif 'distribution' in data:
                dist = DistributionAdapter.load_by_alias(
                    alias=data['distribution']['alias'],
                )
            else:
                dist = None

            if dist:
                dist_pkg = DistributionPackageAdapter.new(
                    distribution=dist,
                    source_package=src_pkg,
                    version=version.version,
                )
            else:
                dist_pkg = None

        product_dist = DistributionAdapter.load_by_alias(
            data.get('product_distribution', {}).get('alias', None))

        if 'product_id' in data:
            product = ProductAdapter.new(
                id=data['product_id'])
        elif 'product' in data:
            product = ProductAdapter.new(
                name=data['product']['name'],
                version=data['product']['version']
            )
            if 'alias' in data['product']:
                product.add_property(name='alias',
                                     value=data['product']['alias'])
        else:
            product = None

        if 'id' in data:
            product_pkg = ProductPackageAdapter.new(
                id=data['id'])
            product_pkg.product = product
            product_pkg.distribution_package = dist_pkg
            product_pkg.version = version.full_version
            product_pkg.product_distribution = product_dist
        else:
            product_pkg = ProductPackageAdapter.new(
                product=product,
                distribution_package=dist_pkg,
                distribution=product_dist,
            )
            product_pkg.version = version.full_version

        if 'package_origin' in data:
            src_pkg.set_property(name='origin',
                                 value=data['package_origin'])

        if 'spec_project' in data:
            product_pkg.set_property(name='spec_project',
                                     value=data['spec_project'])

        if 'source_project' in data:
            product_pkg.set_property(name='source_project',
                                     value=data['source_project'])

        if 'branch' in data:
            product_pkg.set_property(name='branch',
                                     value=data['branch'])

        for patch_name in data.get('patches', []):
            matches = re.findall(
                r'[Cc][Vv][Ee]-((?:\d{4,}|[_-])+)[\._-]',
                patch_name)
            for m in matches:
                parts = m.split('-')
                cve_year = parts.pop(0)
                for cve_number in parts:
                    if cve_number == '':
                        continue
                    cve_name = 'CVE-{}-{}'.format(cve_year, cve_number)
                    cve = CVEAdapter.new(name=cve_name)
                    product_pkg.add_cve(cve, resolved=True)

        for item in data.get('binary_packages'):
            product_pkg.add_binary_package(item['name'])

        # product_pkg.commit()

    def show(self, formatter=None):
        fields = (
            ('ID', '{id}'),
            ('Distribution Package',
             '{distribution_package[__str__]} <{distribution_package[id]}>'),
            ('Source Package',
             '{distribution_package[source_package][__str__]} '
             '<{distribution_package[source_package][id]}>'),
            ('Name', '{distribution_package[source_package][project][name]}'),
            ('Version', '{version}'),
            ('Distribution', '{distribution[__str__]} <{distribution[id]}>'),
            ('Product', '{product[__str__]} <{product[id]}>'),
            ('Product Distribution',
             '{product_distribution[__str__]} <{product_distribution[id]}>'),
        )
        cols, data, raw = super().show(fields=fields, formatter=formatter)

        if formatter == 'TableFormatter':
            for x in raw.get('issues', []):
                cols.append('CVE')
                data.append('{__str__} <{id}>'.format(**x))

            tracked, related = self.related_issues()
            for x in sorted(tracked):
                cols.append('Issue (tracked)')
                data.append(str(tracked[x]['issue']))

            for x in sorted(related):
                for y in related[x]:
                    cols.append('Issue (related)')
                    data.append('{} from {}'
                                .format(x, str(y['issue'].package)))

        return cols, data, raw

    def export(self):
        data = super().export()

        data['binary_packages'] = [
            x.dict() for x in self.binary_packages
        ]

        data['issues'] = [
            x.dict() for x in self.issues()
        ]

        return data

    def dict(self, append={}):
        data = {
            'distribution': self.distribution.dict(),
            'distribution_package': self.distribution_package.dict(),
            'source_package': self.source_package.dict(),
            'product': self.product.dict(),
            'product_distribution': self.product_distribution.dict(),
            'version': self.version,
        }
        super().dict(data=data, append=append)
        return data


class ProductPackageIssueAdapter(GenericAdapter):
    def __str__(self):
        return '{0.issue.name} {0.package!s} ' \
               'Affected:{0.affected} Resolved:{0.resolved}'.format(self)

    def __repr__(self):
        return '{0.model_name}(ID:{0.id}, Issue:{0.issue!s},' \
               ' Package:{0.package!s})'.format(self)

    @property
    def package(self):
        return ProductPackageAdapter(self._.package)

    @property
    def product(self):
        return ProductAdapter(self._.package.product)

    @property
    def issue(self):
        return CVEAdapter(self._.issue)

    @property
    def affected(self):
        return self._.affected

    @affected.setter
    def affected(self, value):
        self.set('affected', value)

    @property
    def status(self):
        return self._.status or '<empty>'

    @status.setter
    def status(self, value):
        self.set('status', value)

    def dict(self, append={}):
        data = {
            'issue': self.issue.dict(),
            'package': self.package.dict(),
            'affected': self.affected,
            'resolved': self.resolved,
            'status': self.status,
            'date_modified': str(self.date_modified),
        }
        super().dict(data=data, append=append)
        return data


class SourcePackageAdapter(GenericAdapter):
    def __str__(self):
        return '{0.name} {0.version}'.format(self)

    def __repr__(self):
        return '{0.model_name}(ID:{0.id}, Name:{0.name},' \
               ' Version:{0.version})'.format(self)

    def issues(self, cve=None):
        filter_by = {'package': self._}
        if cve:
            filter_by['issue'] = cve._
        for x in self.db_api.query(SourcePackageIssue,
                                   SourcePackageIssueAdapter,
                                   filter_by=filter_by):
            yield x

    @property
    def cves(self):
        for x in self._.issues:
            yield SourcePackageIssueAdapter(x)

    @property
    def advisories(self):
        for x in self._.advisories:
            yield AdvisoryAdapter(x)

    @property
    def distributions(self):
        for x in self._.distribution_packages:
            yield DistributionAdapter(x.distribution), x.version

    @property
    def distribution_packages(self):
        for x in self._.distribution_packages:
            yield DistributionPackageAdapter(x)

    @property
    def product_packages(self):
        for x in self.distribution_packages:
            for y in x.product_packages:
                yield ProductPackageAdapter(y)

    @property
    def packages(self):
        dp = None
        for dp in self.distribution_packages:
            pp = None
            for pp in dp.product_packages:
                yield self, dp, pp
            else:
                if pp is None:
                    yield self, dp, pp
        else:
            if dp is None:
                yield self, dp, pp

    @property
    def name(self):
        return self._.project.name

    @property
    def project(self):
        return SourceProjectAdapter(self._.project)

    def add_cve(self, cve, **kwargs):
        self.log.info("Adding CVE {} to source package {}, "
                      "with args '{}'".format(str(cve), str(self), kwargs))

        obj = SourcePackageIssueAdapter.new(package=self._, issue=cve._)
        for attr in ('affected', 'resolved'):
            if attr in kwargs:
                obj.set(attr, kwargs[attr])

        return obj

    def related_issues(self, from_parent=True, from_children=True,
                       exclude=None, merge=False):
        tracked = dict()
        related = dict()
        if exclude is None:
            exclude = list()

        for x in self.issues():
            tracked[x.issue.name] = {'issue': x, 'direct': False}

        if from_children:
            for x in self.distribution_packages:
                if x in exclude:
                    continue
                _tracked, _related = x.related_issues(
                    from_parent=False, from_children=True)

                for key, value in _tracked.items():
                    if key in tracked:
                        continue
                    related.setdefault(key, list()).append(value)

                for key, value in _related.items():
                    if key in tracked:
                        continue
                    related.setdefault(key, list()).extend(value)

        if merge:
            merged = dict()
            for key, value in tracked.items():
                merged[key] = {'tracked': True, 'issues': (value,)}
            for key, value in related.items():
                merged[key] = {'tracked': False, 'issues': value}
            return merged

        return tracked, related

    def show(self, formatter=None):
        fields = (
            ('ID', '{id}'),
            ('Name', '{project[name]}'),
            ('Version', '{version}'),
        )
        cols, data, raw = super().show(fields=fields, formatter=formatter)

        if formatter == 'TableFormatter':
            for x in raw.get('advisories', []):
                cols.append('Advisory')
                data.append(x['name'])

            for x in raw.get('cves', []):
                cols.append('CVE')
                data.append(x['issue']['name'])

            for x in raw.get('distribution_packages', []):
                cols.append('Distribution Package')
                data.append('{__str__} <{id}>'.format(**x))

            for x in raw.get('product_packages', []):
                cols.append('Product Package')
                data.append('{__str__} <{id}>'.format(**x))

            tracked, related = self.related_issues()
            for x in sorted(tracked):
                cols.append('Issue (tracked)')
                data.append(str(tracked[x]['issue']))

            for x in sorted(related):
                for y in related[x]:
                    cols.append('Issue (related)')
                    data.append('{} from {}'
                                .format(x, str(y['issue'].package)))

        return cols, data, raw

    def export(self):
        data = super().export()

        data['advisories'] = [x.dict() for x in self.advisories]
        data['cves'] = [x.dict() for x in self.cves]
        data['project'] = self.project.dict()

        data['distribution_packages'] = []
        data['product_packages'] = []

        for x in self.distribution_packages:
            data['distribution_packages'].append(x.dict())
            for y in x.product_packages:
                data['product_packages'].append(y.dict())

        return data

    def dict(self, append={}):
        data = {
            'version': self.version,
            'project': self.project.dict(),
        }
        super().dict(data=data, append=append)
        return data


class SourcePackageIssueAdapter(GenericAdapter):
    def __str__(self):
        return '{0.issue.name} {0.package!s} ' \
               'Affected:{0.affected} Resolved:{0.resolved}'.format(self)

    def __repr__(self):
        return '{0.model_name}(ID:{0.id}, Issue:{0.issue!s},' \
               ' Package:{0.package!s})'.format(self)

    @property
    def package(self):
        return SourcePackageAdapter(self._.package)

    @property
    def affected(self):
        return self._.affected

    @affected.setter
    def affected(self, value):
        self.set('affected', value)

    @property
    def issue(self):
        return CVEAdapter(self._.issue)

    @property
    def status(self):
        return self._.status or '<empty>'

    @status.setter
    def status(self, value):
        self.set('status', value)

    def dict(self, append={}):
        issue = CVEAdapter(self._.issue)
        data = {
            'issue': issue.dict(),
            'package': self.package.dict(),
            'affected': self.affected,
            'resolved': self.resolved,
            'status': self.status,
            'date_modified': str(self.date_modified),
        }
        super().dict(data=data, append=append)
        return data


class SourceProjectAdapter(GenericAdapter):
    def __str__(self):
        if self.type:
            fmt = '{0.name} {0.type}'
        else:
            fmt = '{0.name}'
        return fmt.format(self)

    @property
    def distribution_packages(self):
        for x in self.source_packages:
            for y in x.distribution_packages:
                yield y

    @property
    def cpes(self):
        for x in self._.cpes:
            yield CPEAdapter(x)

    @property
    def packages(self):
        sp = None
        for sp in self.source_packages:
            dp = None
            for dp in sp.distribution_packages:
                pp = None
                for pp in dp.product_packages:
                    yield sp, dp, pp
                else:
                    if pp is None:
                        yield sp, dp, pp
            else:
                if dp is None:
                    yield sp, dp, pp
        else:
            if sp is None:
                yield sp, dp, pp

    @property
    def source_packages(self):
        for x in self._.source_packages:
            yield SourcePackageAdapter(x)

    @property
    def product_packages(self):
        for x in self.distribution_packages:
            for y in x.product_packages:
                yield y

    @property
    def product_package_issues(self):
        for x in self.product_packages:
            for y in x.issues():
                yield y

    @classmethod
    def new_source_package(cls, project_name, project_alias=None,
                           project_type=None, package_version=None):
        project = SourceProjectAdapter.new(
            name=project_name, alias=project_alias, type=project_type)

        if package_version:
            package = SourcePackageAdapter.new(
                project=project._, version=package_version)
        else:
            package = None

        return project, package

    def add_alias(self, alias):
        if alias.lower() != self.name.lower():
            self.add_property('alias', alias)

    def add_cpe(self, cpe):
        self._.cpes.add(cpe._)

    def add_cpe_wfn(self, wfn):
        cpe = CPEAdapter.new(part=str(wfn.get('part')),
                             vendor=str(wfn.get('vendor')),
                             product=str(wfn.get('product'))
                             )
        self._.cpes.add(cpe._)

    def dict(self, append={}):
        data = {
            'name': self.name,
            'summary': self.summary,
            'type': self.type,
            'homepage': self.homepage,
        }
        super().dict(data=data, append=append)
        return data

    def export(self):
        data = super().export()

        sps = set()
        dps = set()
        pps = set()
        for sp, dp, pp in self.packages:
            sps.add(sp)
            dps.add(dp)
            pps.add(pp)

        data['source_packages'] = [x.dict() for x in sps if x is not None]
        data['distribution_packages'] = [x.dict()
                                         for x in dps if x is not None]
        data['product_packages'] = [x.dict() for x in pps if x is not None]

        return data

    def related_issues(self, from_parent=True, from_children=True,
                       exclude=None, merge=False):
        tracked = dict()
        related = dict()
        if exclude is None:
            exclude = list()

        if from_children:
            for x in self.source_packages:
                if x in exclude:
                    continue
                _tracked, _related = x.related_issues(
                    from_parent=False, from_children=True)

                for key, value in _tracked.items():
                    if key in tracked:
                        continue
                    related.setdefault(key, list()).append(value)

                for key, value in _related.items():
                    if key in tracked:
                        continue
                    related.setdefault(key, list()).extend(value)

        if merge:
            merged = dict()
            for key, value in tracked.items():
                merged[key] = {'tracked': True, 'issues': (value,)}
            for key, value in related.items():
                merged[key] = {'tracked': False, 'issues': value}
            return merged

        return tracked, related

    def show(self, formatter=None):
        fields = (
            ('ID', '{id}'),
            ('Name', '{name}'),
            ('Type', '{type}'),
            ('Homepage', '{homepage}'),
            ('Summary', '{summary}'),
        )
        cols, data, raw = super().show(fields=fields, formatter=formatter)

        if formatter == 'TableFormatter':
            for x in raw.get('source_packages', []):
                cols.append('Source Package')
                data.append('{__str__} <{id}>'.format(**x))

            for x in raw.get('distribution_packages', []):
                cols.append('Distribution Package')
                data.append('{__str__} <{id}>'.format(**x))

            for x in raw.get('product_packages', []):
                cols.append('Product Package')
                data.append('{__str__} <{id}>'.format(**x))

            tracked, related = self.related_issues()
            for x in sorted(tracked):
                cols.append('Issue (tracked)')
                data.append(str(tracked[x]['issue']))

            for x in sorted(related):
                for y in related[x]:
                    cols.append('Issue (related)')
                    data.append('{} from {}'
                                .format(x, str(y['issue'].package)))

        return cols, data, raw

    def refresh(self):
        last_refreshed = self.get_property('last_refreshed', as_scalar=True,
                                           default=None)
        if last_refreshed:
            last_refreshed_str = str(
                datetime.datetime.fromtimestamp(float(last_refreshed.value)))
            self.log.debug("'{}' was refreshed at '{}'"
                           .format(self.name, last_refreshed_str))
            return

        project_type = self.get('type', None)
        if project_type == 'pypi':
            homepage = 'https://pypi.python.org/pypi/{}'.format(self.name)
            url = '{}/json'.format(homepage)
            http = urllib3.PoolManager()
            response = http.request('GET', url)
            if response.status in [200, 301]:
                data = json.loads(response.data.decode('utf-8'))
                info = data.get('info', {})
                self.add_alias(info.get('name', self.name))
                self.set('homepage', info.get('package_url', homepage))
                self.set('summary', info.get('summary', ''))
                self.set_property('last_refreshed', str(time.time()))
        elif project_type == 'rubygem':
            url = 'https://rubygems.org/api/v1/gems/{}.json'.format(self.name)
            http = urllib3.PoolManager()
            response = http.request('GET', url)
            if response.status in [200, 301]:
                data = json.loads(response.data.decode('utf-8'))
                self.add_alias(data.get('name', self.name))
                self.set('homepage', data.get('project_uri', ''))
                self.set('summary', data.get('info', ''))
                self.set_property('last_refreshed', str(time.time()))

    def update(self, data):
        for key in ['description', 'homepage']:
            value = data.get(key, None)
            if value:
                self.set(key, value)
